[
["index.html", "Preface What is R? Why use R? Why not use R? R License and the Open Source Ideal", " Preface What is R? R is a number of things, simultaneously. Depending on who is being asked, R is: A software package A programming language A toolkit for developing statistical and analytical tools An extensive library of statistical and mathematical software and algorithms A scripting language much, much more Why use R? R is cross-platform and runs on Windows, Mac, and Linux (as well as more obscure systems). R provides a vast number of useful statistical tools, many of which have been painstakingly tested. R produces publication-quality graphics in a variety of formats. R plays well with FORTRAN, C, and scripts in many languages. R scales, making it useful for small and large projects. It is NOT Excel. R does not have a meaningfully useful graphical user interface (GUI). Why not use R? R cannot do everything. R is not always the “best” tool for the job. R will not hold your hand. Often, it will slap your hand instead. The documentation can be opaque (but there is documentation). R can drive you crazy (on a good day) or age you prematurely (on a bad one). Finding the right package to do the job you want to do can be challenging; worse, some contributed packages are unreliable. R does not have a meaningfully useful graphical user interface (GUI). R License and the Open Source Ideal R is free (yes, totally free!) and distributed under GNU license. In particular, this license allows one to: Download the source code Modify the source code to your heart’s content Distribute the modified source code and even charge money for it, but you must distribute the modified source code under the original GNU license]{} This license means that R will always be available, will always be open source, and can grow organically without constraint. "],
["why-r.html", "1 Why R? 1.1 What is R? 1.2 Why use R? 1.3 Why not use R? 1.4 R License and the Open Source Ideal", " 1 Why R? 1.1 What is R? R is a number of things, simultaneously. Depending on who is being asked, R is: A software package A programming language A toolkit for developing statistical and analytical tools An extensive library of statistical and mathematical software and algorithms A scripting language much, much more 1.2 Why use R? R is cross-platform and runs on Windows, Mac, and Linux (as well as more obscure systems). R provides a vast number of useful statistical tools, many of which have been painstakingly tested. R produces publication-quality graphics in a variety of formats. R plays well with FORTRAN, C, and scripts in many languages. R scales, making it useful for small and large projects. It is NOT Excel. R does not have a meaningfully useful graphical user interface (GUI). I can develop code for analysis on my Mac laptop. I can then install the same code on our 20k core cluster and run it in parallel on 100 samples, monitor the process, and then update a database (for example) with R when complete. 1.3 Why not use R? R cannot do everything. R is not always the “best” tool for the job. R will not hold your hand. Often, it will slap your hand instead. The documentation can be opaque (but there is documentation). R can drive you crazy (on a good day) or age you prematurely (on a bad one). Finding the right package to do the job you want to do can be challenging; worse, some contributed packages are unreliable.]{} R does not have a meaningfully useful graphical user interface (GUI). 1.4 R License and the Open Source Ideal R is free (yes, totally free!) and distributed under GNU license. In particular, this license allows one to: Download the source code Modify the source code to your heart’s content Distribute the modified source code and even charge money for it, but you must distribute the modified source code under the original GNU license]{} This license means that R will always be available, will always be open source, and can grow organically without constraint. "],
["r-mechanics.html", "2 R Mechanics 2.1 Installing R 2.2 Starting R", " 2 R Mechanics 2.1 Installing R The home page for R is called the Comprehensive R Archive Network (CRAN). The website is not pretty (see figure 2.1), but it has quite a bit of information on it. It is not the best place to find help on R, although it is one of the best places to get R-related software, tools, and updates. knitr::include_graphics(&#39;images/CRAN-screenshot.png&#39;) Figure 2.1: The Comprehensive R Archive Network (CRAN) website Detailed installation instructions are readily available, but here are abbreviated instructions for convenience. 2.1.1 Windows NOTE: See Windows installation instructions for more detail. Install R and RStudio as regular users. To install R, visit the Windows base distribution page. Click on the Download R-3.4.0 for Windows link (or use the latest version available). Click on the installer and make the default selection for each option. To install RStudio, visit the RStudio download page. Click on the current RStudio release for Windows link. Click on the installer and follow default instructions. 2.1.2 Mac NOTE: See R for Mac OS X for more detail. To install R, visit the R for Mac OS X. Click on the the R-3.4.0.pkg link (or use the latest version available). Click on the installer and follow default instructions. To install RStudio, visit the RStudio download page. Click on the current RStudio release for Windows link. Click on the installer and follow default instructions. 2.1.3 Linux NOTE: See distribution-specific instructions for additional detail. On debian-based systems, the easiest way to install R is through a package manager manager, run under an administrator account. On Linux one usually needs to install R packages from source, and R package source often contains C, C++, or Fortran code requiring a compiler and -dev versions of various system libraries. It is therefore convenient to install the -dev version of R. sudo apt-get install r-base r-base-dev When installing source packages, it may be necessary to have access to the -dev version of various system libraries. Many of these are installed as dependencies of r-base-dev; other common examples include the xml and curl libraries sudo apt-get install libxml2-dev sudo apt-get install libcurl-dev Note in particular the use specification of libraries (the lib prefix) and the use of the -dev version. To install RStudio, visit the RStudio download page. Download the appropriate archive for your OS. On Ubuntu, install the .deb installer with sudo dpkg -i rstudio-1.0.136-amd64.deb 2.2 Starting R How to start R depends a bit on the operating system (Mac, Windows, Linux) and interface. In this course, we will largely be using an Integrated Development Environment (IDE) called RStudio, but there is nothing to prohibit using R at the command line or in some other interface (and there are a few). A screenshot of the interface is shown in figure 2.2. Figure 2.2: The Rstudio interface "],
["first-steps.html", "3 First steps 3.1 Interacting with R 3.2 Rules for Names in R 3.3 Resources for Getting Help", " 3 First steps 3.1 Interacting with R The only meaningful way of interacting with R is by typing into the R console. At the most basic level, anything that we type at the command line will fall into one of two categories: Assignments x = 1 y &lt;- 2 Expressions 1 + pi + sin(42) ## [1] 3.23 The assignment type is obvious because either the The “&lt;-” or “=” are used. Note that when we type expressions, R will return a result. In this case, the result of R evaluating 1 + pi + sin(42) is 3.225. The standard R prompt is a “&gt;” sign. When present, R is waiting for the next expression or assignment. If a line is not a complete R command, R will continue the next line with a “+”. For example, typing the fillowing with a “Return” after the second “+” will result in R giving back a “+” on the next line, a prompt to keep typing. 1 + pi + sin(3.7) ## [1] 3.61 3.2 Rules for Names in R R allows users to assign names to objects such as variables, functions, and even dimensions of data. However, these names must follow a few rules. Names may contain any combination of letters, numbers, underscore, and “.” Names may not start with numbers, underscore. R names are case-sensitive. Examples of valid R names include: pi x camelCaps my_stuff MY_Stuff this.is.the.name.of.the.man ABC123 abc1234asdf .hi 3.3 Resources for Getting Help There is extensive built-in help and documentation within R. If the name of the function or object on which help is sought is known, the following approaches with the name of the function or object will be helpful. For a concrete example, examine the help for the print method. help(print) help(&#39;print&#39;) ?print If the name of the function or object on which help is sought is not known, the following from within R will be helpful. help.search(&#39;microarray&#39;) RSiteSearch(&#39;microarray&#39;) There are also tons of online resources that Google will include in searches if online searching feels more appropriate. I strongly recommend using help(newfunction) for all functions that are new or unfamiliar to you. "],
["introduction-to-r-data-structures.html", "4 Introduction to R data structures 4.1 Vectors 4.2 Rectangular Data 4.3 Lists and Objects", " 4 Introduction to R data structures As in many programming languages, understanding how data are stored and manipulated is important to getting the most out of the experience. In these next few sections, we will introduce some basic R data types and structures as well as some general approaches for working with them. 4.1 Vectors In R, even a single value is a vector with length=1. z = 1 z ## [1] 1 length(z) ## [1] 1 In the code above, we “assigned” the value 1 to the variable named z. Typing z by itself is an “expression” that returns a result which is, in this case, the value that we just assigned. The length method takes an R object and returns the R length. There are numerous ways of asking R about what an object represents, and length is one of them. Vectors can contain numbers, strings (character data), or logical values (TRUE and FALSE) or other “atomic” data types (table 4.1). Vectors cannot contain a mix of types! We will introduce another data structure, the R list for situations when we need to store a mix of base R data types. Table 4.1: Atomic (simplest) data types in R. Data type Stores numeric floating point numbers integer integers complex complex numbers factor categorical data character strings logical TRUE or FALSE NA missing NULL empty function function type 4.1.1 Creating vectors Character vectors (also sometimes called “string” vectors) are entered with each value surrounded by single or double quotes; either is acceptable, but they must match. They are always displayed by R with double quotes. Here are some examples of creating vectors: # examples of vectors c(&#39;hello&#39;,&#39;world&#39;) ## [1] &quot;hello&quot; &quot;world&quot; c(1,3,4,5,1,2) ## [1] 1 3 4 5 1 2 c(1.12341e7,78234.126) ## [1] 11234100 78234 c(TRUE,FALSE,TRUE,TRUE) ## [1] TRUE FALSE TRUE TRUE # note how in the next case the TRUE is converted to &quot;TRUE&quot; # with quotes around it. c(TRUE,&#39;hello&#39;) ## [1] &quot;TRUE&quot; &quot;hello&quot; We can also create vectors as “regular sequences” of numbers. For example: # create a vector of integers from 1 to 10 x = 1:10 # and backwards x = 10:1 The seq function can create more flexible regular sequences. # create a vector of numbers from 1 to 4 skipping by 0.3 y = seq(1,4,0.3) And creating a new vector by concatenating existing vectors is possible, as well. # create a sequence by concatenating two other sequences z = c(y,x) z ## [1] 1.0 1.3 1.6 1.9 2.2 2.5 2.8 3.1 3.4 3.7 4.0 10.0 9.0 8.0 ## [15] 7.0 6.0 5.0 4.0 3.0 2.0 1.0 4.1.2 Vector Operations Operations on a single vector are typically done element-by-element. For example, we can add 2 to a vector, 2 is added to each element of the vector and a new vector of the same length is returned. x = 1:10 x + 2 ## [1] 3 4 5 6 7 8 9 10 11 12 If the operation involves two vectors, the following rules apply. If the vectors are the same length: R simply applies the operation to each pair of elements. x + x ## [1] 2 4 6 8 10 12 14 16 18 20 If the vectors are different lengths, but one length a multiple of the other, R reuses the shorter vector as needed. x = 1:10 y = c(1,2) x * y ## [1] 1 4 3 8 5 12 7 16 9 20 If the vectors are different lengths, but one length not a multiple of the other, R reuses the shorter vector as needed and delivers a warning. x = 1:10 y = c(2,3,4) x * y ## Warning in x * y: longer object length is not a multiple of shorter object ## length ## [1] 2 6 12 8 15 24 14 24 36 20 Typical operations include multiplication (“*”), addition, subtraction, division, exponentiation (“^”), but many operations in R operate on vectors and are then called “vectorized”. 4.1.3 Logical Vectors Logical vectors are vectors composed on only the values TRUE and FALSE. Note the all-upper-case and no quotation marks. a = c(TRUE,FALSE,TRUE) # we can also create a logical vector from a numeric vector # 0 = false, everything else is 1 b = c(1,0,217) d = as.logical(b) d ## [1] TRUE FALSE TRUE # test if a and d are the same at every element all.equal(a,d) ## [1] TRUE # We can also convert from logical to numeric as.numeric(a) ## [1] 1 0 1 4.1.4 Logical Operators Some operators like &lt;, &gt;, ==, &gt;=, &lt;=, != can be used to create logical vectors. # create a numeric vector x = 1:10 # testing whether x &gt; 5 creates a logical vector x &gt; 5 ## [1] FALSE FALSE FALSE FALSE FALSE TRUE TRUE TRUE TRUE TRUE x &lt;= 5 ## [1] TRUE TRUE TRUE TRUE TRUE FALSE FALSE FALSE FALSE FALSE x != 5 ## [1] TRUE TRUE TRUE TRUE FALSE TRUE TRUE TRUE TRUE TRUE x == 5 ## [1] FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE We can also assign the results to a variable: y = (x == 5) y ## [1] FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE 4.1.5 Indexing Vectors In R, an index is used to refer to a specific element or set of elements in an vector (or other data structure). [R uses [ and ] to perform indexing, although other approaches to getting subsets of larger data structures are common in R. x = seq(0,1,0.1) # create a new vector from the 4th element of x x[4] ## [1] 0.3 We can even use other vectors to perform the “indexing”. x[c(3,5,6)] ## [1] 0.2 0.4 0.5 y = 3:6 x[y] ## [1] 0.2 0.3 0.4 0.5 Combining the concept of indexing with the concept of logical vectors results in a very power combination. # use help(&#39;rnorm&#39;) to figure out what is happening next myvec = rnorm(10) # create logical vector that is TRUE where myvec is &gt;0.25 gt1 = (myvec &gt; 0.25) sum(gt1) ## [1] 3 # and use our logical vector to create a vector of myvec values that are &gt;0.25 myvec[gt1] ## [1] 1.559 1.715 0.461 # or &lt;=0.25 using the logical &quot;not&quot; operator, &quot;!&quot; myvec[!gt1] ## [1] -0.5605 -0.2302 0.0705 0.1293 -1.2651 -0.6869 -0.4457 # shorter, one line approach myvec[myvec &gt; 0.25] ## [1] 1.559 1.715 0.461 4.1.6 Character Vectors, A.K.A. Strings R uses the paste function to concatenate strings. paste(&quot;abc&quot;,&quot;def&quot;) ## [1] &quot;abc def&quot; paste(&quot;abc&quot;,&quot;def&quot;,sep=&quot;THISSEP&quot;) ## [1] &quot;abcTHISSEPdef&quot; paste0(&quot;abc&quot;,&quot;def&quot;) ## [1] &quot;abcdef&quot; ## [1] &quot;abcdef&quot; paste(c(&quot;X&quot;,&quot;Y&quot;),1:10) ## [1] &quot;X 1&quot; &quot;Y 2&quot; &quot;X 3&quot; &quot;Y 4&quot; &quot;X 5&quot; &quot;Y 6&quot; &quot;X 7&quot; &quot;Y 8&quot; &quot;X 9&quot; &quot;Y 10&quot; paste(c(&quot;X&quot;,&quot;Y&quot;),1:10,sep=&quot;_&quot;) ## [1] &quot;X_1&quot; &quot;Y_2&quot; &quot;X_3&quot; &quot;Y_4&quot; &quot;X_5&quot; &quot;Y_6&quot; &quot;X_7&quot; &quot;Y_8&quot; &quot;X_9&quot; &quot;Y_10&quot; We can count the number of characters in a string. nchar(&#39;abc&#39;) ## [1] 3 nchar(c(&#39;abc&#39;,&#39;d&#39;,123456)) ## [1] 3 1 6 Pulling out parts of strings is also sometimes useful. substr(&#39;This is a good sentence.&#39;,start=10,stop=15) ## [1] &quot; good &quot; Another common operation is to replace something in a string with something (a find-and-replace). sub(&#39;This&#39;,&#39;That&#39;,&#39;This is a good sentence.&#39;) ## [1] &quot;That is a good sentence.&quot; When we want to find all strings that match some other string, we can use grep, or “grab regular expression”. grep(&#39;bcd&#39;,c(&#39;abcdef&#39;,&#39;abcd&#39;,&#39;bcde&#39;,&#39;cdef&#39;,&#39;defg&#39;)) ## [1] 1 2 3 grep(&#39;bcd&#39;,c(&#39;abcdef&#39;,&#39;abcd&#39;,&#39;bcde&#39;,&#39;cdef&#39;,&#39;defg&#39;),value=TRUE) ## [1] &quot;abcdef&quot; &quot;abcd&quot; &quot;bcde&quot; 4.1.7 Missing Values, AKA “NA” R has a special value, “NA”, that represents a “missing” value, or Not Available, in a vector or other data structure. Here, we just create a vector to experiment. x = 1:5 x ## [1] 1 2 3 4 5 length(x) ## [1] 5 is.na(x) ## [1] FALSE FALSE FALSE FALSE FALSE x[2] = NA x ## [1] 1 NA 3 4 5 The length of x is unchanged, but there is one value that is marked as “missing” by virtue of being NA. length(x) ## [1] 5 is.na(x) ## [1] FALSE TRUE FALSE FALSE FALSE We can remove NA values by using indexing. In the following, is.na(x) returns a logical vector the length of x. The ! is the logical NOT operator and converts TRUE to FALSE and vice-versa. x[!is.na(x)] ## [1] 1 3 4 5 4.1.8 Factors A factor is a special type of vector, normally used to hold a categorical variable–such as smoker/nonsmoker, state of residency, zipcode–in many statistical functions. Such vectors have class “factor”. Factors are primarily used in Analysis of Variance (ANOVA) or other situations when “categories” are needed. When a factor is used as a predictor variable, the corresponding indicator variables are created (more later). Note of caution that factors in R often appear to be character vectors when printed, but you will notice that they do not have double quotes around them. They are stored in R as numbers with a key name, so sometimes you will note that the factor behaves like a numeric vector. # create the character vector citizen&lt;-c(&quot;uk&quot;,&quot;us&quot;,&quot;no&quot;,&quot;au&quot;,&quot;uk&quot;,&quot;us&quot;,&quot;us&quot;,&quot;no&quot;,&quot;au&quot;) # convert to factor citizenf&lt;-factor(citizen) citizen ## [1] &quot;uk&quot; &quot;us&quot; &quot;no&quot; &quot;au&quot; &quot;uk&quot; &quot;us&quot; &quot;us&quot; &quot;no&quot; &quot;au&quot; citizenf ## [1] uk us no au uk us us no au ## Levels: au no uk us # convert factor back to character vector as.character(citizenf) ## [1] &quot;uk&quot; &quot;us&quot; &quot;no&quot; &quot;au&quot; &quot;uk&quot; &quot;us&quot; &quot;us&quot; &quot;no&quot; &quot;au&quot; # convert to numeric vector as.numeric(citizenf) ## [1] 3 4 2 1 3 4 4 2 1 R stores many data structures as vectors with “attributes” and “class” (just so you have seen this). attributes(citizenf) ## $levels ## [1] &quot;au&quot; &quot;no&quot; &quot;uk&quot; &quot;us&quot; ## ## $class ## [1] &quot;factor&quot; class(citizenf) ## [1] &quot;factor&quot; # note that after unclassing, we can see the # underlying numeric structure again unclass(citizenf) ## [1] 3 4 2 1 3 4 4 2 1 ## attr(,&quot;levels&quot;) ## [1] &quot;au&quot; &quot;no&quot; &quot;uk&quot; &quot;us&quot; Tabulating factors is a useful way to get a sense of the “sample” set available. table(citizenf) ## citizenf ## au no uk us ## 2 2 2 3 4.2 Rectangular Data A matrix is a rectangular collection of the same data type. It can be viewed as a collection of column vectors all of the same length and the same type (i.e. numeric, character or logical). A data.frame is also a rectangular array. All of the columns must be the same length, but they may be of different types. The rows and columns of a matrix or data frame can be given names. However these are implemented differently in R; many operations will work for one but not both, often a source of confusion. 4.2.1 Matrices We start by building a matrix from parts: x &lt;- 1:10 y &lt;- rnorm(10) # make a matrix by column binding two numeric vectors mat&lt;-cbind(x,y) mat ## x y ## [1,] 1 1.224 ## [2,] 2 0.360 ## [3,] 3 0.401 ## [4,] 4 0.111 ## [5,] 5 -0.556 ## [6,] 6 1.787 ## [7,] 7 0.498 ## [8,] 8 -1.967 ## [9,] 9 0.701 ## [10,] 10 -0.473 Inspecting the names associated with rows and columns is often useful, particularly if the names have human meaning. rownames(mat) ## NULL colnames(mat) ## [1] &quot;x&quot; &quot;y&quot; Matrices have dimensions. dim(mat) ## [1] 10 2 nrow(mat) ## [1] 10 ncol(mat) ## [1] 2 Indexing for matrices works as for vectors except that we now need to include both the row and column (in that order). # The 2nd element of the 1st row of mat mat[1,2] ## y ## 1.22 # The first ROW of mat mat[1,] ## x y ## 1.00 1.22 # The first COLUMN of mat mat[,1] ## [1] 1 2 3 4 5 6 7 8 9 10 # and all elements of mat that are &gt; 4; note no comma mat[mat&gt;4] ## [1] 5 6 7 8 9 10 ## [1] 5 6 7 8 9 10 Note that in the last case, there is no “,”, so R treats the matrix as a long vector (length=20). This is convenient, sometimes, but it can also be a source of error, as some code may “work” but be doing something unexpected. In the next example, we create a matrix with 2 columns and 10 rows. m = matrix(rnorm(20),nrow=10) # multiply all values in the matrix by 20 m = m*20 # and add 100 to the first column of m m[,1] = m[,1] + 100 # summarize m summary(m) ## V1 V2 ## Min. : 66.3 Min. :-7.61 ## 1st Qu.: 78.9 1st Qu.:-4.74 ## Median : 86.5 Median : 9.80 ## Mean : 91.5 Mean : 6.44 ## 3rd Qu.:101.2 3rd Qu.:15.77 ## Max. :125.1 Max. :17.90 4.2.2 Data Frames 4.2.2.1 Matrices Versus Data Frames mat&lt;-cbind(x,y) head(mat) ## x y ## [1,] 1 1.224 ## [2,] 2 0.360 ## [3,] 3 0.401 ## [4,] 4 0.111 ## [5,] 5 -0.556 ## [6,] 6 1.787 class(mat[,1]) ## [1] &quot;numeric&quot; z = paste0(&#39;a&#39;,1:10) tab&lt;-cbind(x,y,z) class(tab) ## [1] &quot;matrix&quot; mode(tab[,1]) ## [1] &quot;character&quot; head(tab,4) ## x y z ## [1,] &quot;1&quot; &quot;1.22408179743946&quot; &quot;a1&quot; ## [2,] &quot;2&quot; &quot;0.359813827057364&quot; &quot;a2&quot; ## [3,] &quot;3&quot; &quot;0.400771450594052&quot; &quot;a3&quot; ## [4,] &quot;4&quot; &quot;0.11068271594512&quot; &quot;a4&quot; tab&lt;-data.frame(x,y,z) class(tab) ## [1] &quot;data.frame&quot; head(tab) ## x y z ## 1 1 1.224 a1 ## 2 2 0.360 a2 ## 3 3 0.401 a3 ## 4 4 0.111 a4 ## 5 5 -0.556 a5 ## 6 6 1.787 a6 mode(tab[,1]) ## [1] &quot;numeric&quot; class(tab[,3]) ## [1] &quot;factor&quot; rownames(tab) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; rownames(tab)&lt;-paste0(&quot;row&quot;,1:10) rownames(tab) ## [1] &quot;row1&quot; &quot;row2&quot; &quot;row3&quot; &quot;row4&quot; &quot;row5&quot; &quot;row6&quot; &quot;row7&quot; &quot;row8&quot; ## [9] &quot;row9&quot; &quot;row10&quot; Data frame columns can be refered to by name using the “dollar sign” operator. head(tab) ## x y z ## row1 1 1.224 a1 ## row2 2 0.360 a2 ## row3 3 0.401 a3 ## row4 4 0.111 a4 ## row5 5 -0.556 a5 ## row6 6 1.787 a6 tab$x ## [1] 1 2 3 4 5 6 7 8 9 10 tab$y ## [1] 1.224 0.360 0.401 0.111 -0.556 1.787 0.498 -1.967 0.701 -0.473 Column names can be set, which can be useful for referring to data later. colnames(tab) ## [1] &quot;x&quot; &quot;y&quot; &quot;z&quot; colnames(tab) = paste0(&#39;col&#39;,1:3) Data frames have functions to report size and even summary functions. Try the following: ncol(tab) ## [1] 3 nrow(tab) ## [1] 10 dim(tab) ## [1] 10 3 summary(tab) ## col1 col2 col3 ## Min. : 1.00 Min. :-1.967 a1 :1 ## 1st Qu.: 3.25 1st Qu.:-0.327 a10 :1 ## Median : 5.50 Median : 0.380 a2 :1 ## Mean : 5.50 Mean : 0.209 a3 :1 ## 3rd Qu.: 7.75 3rd Qu.: 0.650 a4 :1 ## Max. :10.00 Max. : 1.787 a5 :1 ## (Other):4 Extracting parts of a data.frame work as for matrices. Try to think about what each of the following will do before asking R to evaluate the result. tab[1:3,] ## col1 col2 col3 ## row1 1 1.224 a1 ## row2 2 0.360 a2 ## row3 3 0.401 a3 tab[,2:3] ## col2 col3 ## row1 1.224 a1 ## row2 0.360 a2 ## row3 0.401 a3 ## row4 0.111 a4 ## row5 -0.556 a5 ## row6 1.787 a6 ## row7 0.498 a7 ## row8 -1.967 a8 ## row9 0.701 a9 ## row10 -0.473 a10 tab[,1]&gt;7 ## [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE TRUE TRUE tab[tab[,1]&gt;7,] ## col1 col2 col3 ## row8 8 -1.967 a8 ## row9 9 0.701 a9 ## row10 10 -0.473 a10 tab[tab[,1]&gt;7,3] ## [1] a8 a9 a10 ## Levels: a1 a10 a2 a3 a4 a5 a6 a7 a8 a9 tab[tab[,1]&gt;7,2:3] ## col2 col3 ## row8 -1.967 a8 ## row9 0.701 a9 ## row10 -0.473 a10 tab[tab$x&gt;7,3] ## factor(0) ## Levels: a1 a10 a2 a3 a4 a5 a6 a7 a8 a9 tab$z[tab$x&gt;3] ## NULL 4.3 Lists and Objects A list is a collection of objects that may be the same or different types. The objects in a list often have names, and may be indexed either by name (e.g. my_list$name3) or component number (e.g. my_list[[3]]). As an aside, a data frame is a list of matched column vectors. We can reate a list, noting the different data types involved. a = list(1,&quot;b&quot;,c(1,2,3)) a ## [[1]] ## [1] 1 ## ## [[2]] ## [1] &quot;b&quot; ## ## [[3]] ## [1] 1 2 3 length(a) ## [1] 3 class(a) ## [1] &quot;list&quot; a[[3]] ## [1] 1 2 3 A data frame is a list. # test if our friend &quot;tab&quot; is a list is.list(tab) ## [1] TRUE tab[[2]] ## [1] 1.224 0.360 0.401 0.111 -0.556 1.787 0.498 -1.967 0.701 -0.473 names(tab) ## [1] &quot;col1&quot; &quot;col2&quot; &quot;col3&quot; Table (#tab:datatypes) Summary of basic R data structures. Data type S tores vector one-dimensional data, single data type matrix two-dimensional data, single data type data frame two-dimensional data, multiple data types list list of data types, not all need to be the same type object a list with attributes and potentially slots and methods "],
["plotting-and-graphics.html", "5 Plotting and Graphics 5.1 Base R graphics 5.2 Plotting with ggplot2 5.3 Graphics Devices and Saving Plots", " 5 Plotting and Graphics Visit these sites for some ideas. http://www.sr.bham.ac.uk/~ajrs/R/r-gallery.html http://gallery.r-enthusiasts.com/ http://cran.r-project.org/web/views/Graphics.html 5.1 Base R graphics The command plot(x,y) will plot vector x as the independent variable and vector y as the dependent variable. Within the command line, you can specify the title of the graph, the name of the x-axis, and the name of the y-axis. - main=’title’ - xlab=’name of x axis’ - ylab=’name of y axis’ The command lines(x,y) adds a line segment to an existing plot. The command points(x,y) adds points to the plot. A legend can be created using legend, though getting the legend right for base graphics can be a bit challenging. To get a basic idea of what R offers, it has a build-in demo that can be run with demo(graphics). Try this yourself: x = 1:100 y = rnorm(100,3,1) # 100 random normal deviates with mean=3, sd=1 plot(x,y) plot(x,y,main=&#39;My First Plot&#39;) # change point type plot(x,y,pch=3) # change color plot(x,y,pch=4,col=2) # draw lines between points lines(x,y,col=3) z=sort(y) # plot a sorted variable vs x plot(x,z,main=&#39;Random Normal Numbers&#39;, xlab=&#39;Index&#39;,ylab=&#39;Random Number&#39;) # A basic histogram hist(z, main=&quot;Histogram&quot;, sub=&quot;Random normal&quot;) # A &quot;density&quot; plot plot(density(z), main=&quot;Density plot&quot;, sub=&quot;Random normal&quot;) # A smaller &quot;bandwidth&quot; to capture more detail plot(density(z, adjust=0.5), sub=&quot;smaller bandwidth&quot;) 5.2 Plotting with ggplot2 The ggplot2 package is a relatively novel approach to generating highly informative publication-quality graphics. The “gg” stands for “Grammar of Graphics”. In short, instead of thinking about a single function that produces a plot, ggplot2 uses a “grammar” approach, akin to building more and more complex sentences to layer on more information or nuance. See the ggplot2 graphics gallery for some examples with accompanying code. The ggplot2 package assumes that data are in the form of a data.frame. In some cases, the data will need to be manipulated into a form that matches assumptions that ggplot2 uses. In particular, if one has a matrix of numbers associated with different subjects (samples, people, etc.), the data will usually need to be transformed into a “long” data frame. To use the ggplot2 package, it must be installed and loaded. Assuming that installation has been done already, we can load the package directly: library(ggplot2) 5.2.1 mtcars data We are going to use the mtcars dataset, included with R, to experiment with ggplot2. data(mtcars) Exercise: Explore the mtcars dataset using View, summary, dim, class, etc. We can also take a quick look at the relationships between the variables using the pairs plotting function. pairs(mtcars) That is a useful view of the data. We want to use ggplot2 to make an informative plot, so let’s approach this in a piecewise fashion. We first need to decide what type of plot to produce and what our basic variables will be. In this case, we have a number of choices. ggplot(mtcars,aes(x=disp,y=hp)) First, a little explanation is necessary. The ggplot function takes as its first argument a data.frame. The second argument is the “aesthetic”, aes. The x and y take column names from the mtcars data.frame and will form the basis of our scatter plot. But why did we get that “Error: No layers in plot”? Remember that ggplot2 is a “grammar of graphics”. We supplied a subject, but no verb (called a layer by ggplot2). So, to generate a plot, we need to supply a verb. There are many possibilities. Each “verb” or layer typically starts with “geom” and then a descriptor. An example is necessary. ggplot(mtcars,aes(x=disp,y=hp)) + geom_point() We finally produced a plot. The power of ggplot2, though, is the ability to make very rich plots by adding “grammar” to the “plot sentence”. We have a number of other variables in our mtcars data.frame. How can we add another value to a two-dimensional plot? ggplot(mtcars,aes(x=disp,y=hp,color=cyl)) + geom_point() The color of the points is a based on the numeric variable wt, the weight of the car. Can we do more? We can change the size of the points, also. ggplot(mtcars,aes(x=disp,y=hp,color=wt,size=mpg)) + geom_point() So, on our 2D plot, we are now plotting four variables. Can we do more? We can manipulate the shape of the points in addition to the color and the size. ggplot(mtcars,aes(x=disp,y=hp)) + geom_point(aes(size=mpg,color=wt,shape=cyl)) Why did we get that error? Ggplot2 is trying to be helpful by telling us that a “continuous varialbe cannot be mapped to ‘shape’”. Well, in our mtcars data.frame, we can look at cyl in detail. class(mtcars$cyl) ## [1] &quot;numeric&quot; summary(mtcars$cyl) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 4.00 4.00 6.00 6.19 8.00 8.00 table(mtcars$cyl) ## ## 4 6 8 ## 11 7 14 The cyl variable is “kinda” continuous in that it is numeric, but it could also be thought of as a “category” of engines. R has a specific data type for “category” data, called a factor. We can easily convert the cyl column to a factor like so: mtcars$cyl = as.factor(mtcars$cyl) Now, we can go ahead with our previous approach to make a 2-dimensional plot that displays the relationships between five variables. ggplot(mtcars,aes(x=disp,y=hp)) + geom_point(aes(size=mpg,color=wt,shape=cyl)) Additional exercises Use geom_text to add labels to your plot. Convert all your work to plotly for interactive versions of the plots. 5.2.2 NYC Flight data I leave this section open-ended for you to explore further options with the ggplot2 package. The data represent the on-time data for all flights that departed New York City in 2013. # install.packages(&#39;nycflights13&#39;) library(nycflights13) data(flights) head(flights) ## # A tibble: 6 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 ## 2 2013 1 1 533 529 4 850 ## 3 2013 1 1 542 540 2 923 ## 4 2013 1 1 544 545 -1 1004 ## 5 2013 1 1 554 600 -6 812 ## 6 2013 1 1 554 558 -4 740 ## # ... with 12 more variables: sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, ## # time_hour &lt;dttm&gt; Use ggplot and other plotting tools to explore the data and look for features that might contribute to airport delays. Consider using other “geoms” during your exploration. 5.3 Graphics Devices and Saving Plots To make a plot directly to a file use: png(), postscript(), etc. png(file=&quot;myplot.png&quot;,width=480,height=480) plot(density(z,adjust=2.0),sub=&quot;larger bandwidth&quot;) dev.off() ## png ## 2 On your own, save a pdf to a file. NOTE: The dimensions in pdf() are in inches. To put multiple plots on a page, we can set the mfrow graphics parameter. par(mfrow=c(2,1)) plot(density(z,adjust=2.0),sub=&quot;larger bandwidth&quot;) hist(z) # use dev.off() to turn off the two-row plotting R can have multiple graphics “devices” open. To see a list of active devices: dev.list() To close the most recent device: dev.off() To close device 5: dev.off(5) To use device 5: dev.set(5) "],
["control-structures-looping-and-applying.html", "6 Control Structures, Looping, and Applying 6.1 Control Structures and Looping 6.2 Applying", " 6 Control Structures, Looping, and Applying 6.1 Control Structures and Looping 6.1.1 Control Structures in R R has multiple types of control structures that allows for sequential evaluation of statements. For loops for (x in set) {operations} while loops while (x in condition){operations} If statements (conditional) if (condition) { some operations } else { other operations } 6.1.2 Control Structure and Looping Examples x&lt;-1:9 length(x) # a simple conditional then two expressions if (length(x)&lt;=10) { x&lt;-c(x,10:20);print(x)} # more complex if (length(x)&lt;5) { print(x) } else { print(x[5:20]) } # print the values of x, one at a time for (i in x) print(i) for(i in x) i # note R will not echo in a loop 6.1.3 Control Structure and Looping Examples # loop over a character vector y&lt;-c(&#39;a&#39;,&#39;b&#39;,&#39;hi there&#39;) for (i in y) print(i) # and a while loop j&lt;-1 while(j&lt;10) { # do this while j&lt;10 print(j) j&lt;-j+2} # at each iteration, increase j by 2 6.2 Applying 6.2.1 Why Does R Have Apply Functions Often we want to apply the same function to all the rows or columns of a matrix, or all the elements of a list. We could do this in a loop, but loops take a lot of time in an interpreted language like R. R has more efficient built-in operators, the apply functions. example If mat is a matrix and fun is a function (such as mean, var, lm …) that takes a vector as its argument, then you can: apply(mat,1,fun) # over rows--second argument is 1 apply(mat,2,fun) # over columns--second argument is 2 In either case, the output is a vector. 6.2.2 Apply Function Exercise Using the matrix and rnorm functions, create a matrix with 20 rows and 10 columns (200 values total) of random normal deviates. Compute the mean for each row of the matrix. Compute the median for each column. 6.2.3 Related Apply Functions lapply(list, function) applies the function to every element of list sapply(list or vector, function) applies the function to every element of list or vector, and returns a vector, when possible (easier to process) tapply(x, factor, fun) uses the factor to split vector x into groups, and then applies fun to each group 6.2.4 Related Apply Function Examples # create a list my.list &lt;- list(a=1:3,b=5:10,c=11:20) my.list # Get the mean for each member of the list # return a vector sapply( my.list, mean) # Get the full summary for each member of # the list, returned as a list lapply( my.list, summary) # Find the mean for each group defined by a factor my.vector &lt;- 1:10 my.factor &lt;- factor( c(1,1,1,2,2,2,3,3,3,3)) tapply(my.vector, my.factor, mean) "],
["functions.html", "7 Functions", " 7 Functions 7.0.1 Function Overview Functions are objects and are assigned to names, just like data. myFunction = function(argument1,argument2) { expression1 expression2 } We write functions for anything we need to do again and again. You may test your commands interactively at first, and then use the history() feature and an editor to create the function. It is wise to include a comment at the start of each function to say what it does and to document functions of more than a few lines. 7.0.2 Example Functions add1 = function(x) { # this function adds one to the first argument and returns it x + 1 } add1(17) ## [1] 18 add1(c(17,18,19,20)) ## [1] 18 19 20 21 You can use the edit() function to make changes to a function. The following command will open a window, allow you to make changes, and assign the result to a new function, add2. add2 = edit(add1) 7.0.3 Further Reading The amount of learning material for R is simply astonishing! Thomas Girke’s R and Bioconductor Manual A HUGE collection of contributed R documentation and tutorials Bioconductor course materials Sean Davis’ website The Official R Manuals "],
["data-input-and-exploration.html", "8 Data Input and Exploration 8.1 Behavioral Risk Factor Surveillance System 8.2 ALL Phenotypic Data", " 8 Data Input and Exploration 8.1 Behavioral Risk Factor Surveillance System We will explore a subset of data collected by the CDC through its extensive Behavioral Risk Factor Surveillance System (BRFSS) telephone survey. Check out the link for more information. We’ll look at a subset of the data. First, we need to get the data. Either download the data from THIS LINK or have R do it directly from the command-line (preferred): download.file(&#39;https://raw.githubusercontent.com/seandavi/ITR/master/BRFSS-subset.csv&#39;, destfile = &#39;BRFSS-subset.csv&#39;) You can check to see the file using the Rstudio file panel or get a directory listing using dir() Use file.choose() to find the path to the file ‘BRFSS-subset.csv’ path &lt;- file.choose() Read the data into R using read.csv(), assigning to a variable brfss. brfss &lt;- read.csv(path) Use command like class(), head(), dim(), summary() to explore the data. What variables have been measured? Can you guess at the units used for, e.g., Weight and Height? class(brfss) head(brfss) dim(brfss) summary(brfss) Use the $ operator to extract the ‘Sex’ column, and summarize the number of males and females in the survey using table(). Do the same for ‘Year’, and for both Sex and Year table(brfss$Sex) ## ## Female Male ## 12039 7961 table(brfss$Year) ## ## 1990 2010 ## 10000 10000 table(brfss$Sex, brfss$Year) ## ## 1990 2010 ## Female 5718 6321 ## Male 4282 3679 with(brfss, table(Sex, Year)) # same, but easier ## Year ## Sex 1990 2010 ## Female 5718 6321 ## Male 4282 3679 Use aggregate() to summarize the mean weight of each group. What about the median weight of each group? What about the number of observations in each group? with(brfss, aggregate(Weight, list(Year, Sex), mean, na.rm=TRUE)) ## Group.1 Group.2 x ## 1 1990 Female 64.8 ## 2 2010 Female 73.0 ## 3 1990 Male 81.2 ## 4 2010 Male 88.8 with(brfss, aggregate(Weight, list(Year=Year, Sex=Sex), mean, na.rm=TRUE)) ## Year Sex x ## 1 1990 Female 64.8 ## 2 2010 Female 73.0 ## 3 1990 Male 81.2 ## 4 2010 Male 88.8 Use a formula and the aggregate() function to describe the relationship between Year, Sex, and Weight aggregate(Weight ~ Year + Sex, brfss, mean) # same, but more informative ## Year Sex Weight ## 1 1990 Female 64.8 ## 2 2010 Female 73.0 ## 3 1990 Male 81.2 ## 4 2010 Male 88.8 aggregate(. ~ Year + Sex, brfss, mean) # all variables ## Year Sex Age Weight Height ## 1 1990 Female 46.1 64.8 163 ## 2 2010 Female 57.1 73.0 163 ## 3 1990 Male 43.9 81.2 178 ## 4 2010 Male 56.3 88.9 178 Create a subset of the data consisting of only the 1990 observations. Perform a t-test comparing the weight of males and females (“‘Weight’ as a function of ‘Sex’”, Weight ~ Sex) brfss_1990 = brfss[brfss$Year == 1990,] t.test(Weight ~ Sex, brfss_1990) ## ## Welch Two Sample t-test ## ## data: Weight by Sex ## t = -60, df = 9000, p-value &lt;2e-16 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## -16.9 -15.8 ## sample estimates: ## mean in group Female mean in group Male ## 64.8 81.2 t.test(Weight ~ Sex, brfss, subset = Year == 1990) ## ## Welch Two Sample t-test ## ## data: Weight by Sex ## t = -60, df = 9000, p-value &lt;2e-16 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## -16.9 -15.8 ## sample estimates: ## mean in group Female mean in group Male ## 64.8 81.2 What about differences between weights of males (or females) in 1990 versus 2010? Check out the help page ?t.test.formula. Is there a way of performing a t-test on brfss without explicitly creating the object brfss_1990? Use boxplot() to plot the weights of the Male individuals. Can you transform weight, e.g., sqrt(Weight) ~ Year? Interpret the results. Do similar boxplots for the t-tests of the previous question. boxplot(Weight ~ Year, brfss, subset = Sex == &quot;Male&quot;, main=&quot;Males&quot;) Use hist() to plot a histogram of weights of the 1990 Female individuals. hist(brfss_1990[brfss_1990$Sex == &quot;Female&quot;, &quot;Weight&quot;], main=&quot;Females, 1990&quot;, xlab=&quot;Weight&quot; ) 8.1.1 ggplot2 library(ggplot2) http://docs.ggplot2.org ‘Grammar of graphics’ Specify data and ‘aesthetics’ (aes()) to be plotted Add layers (geom_*()) of information Clean it by coercing Year to factor. A factor is a categorical variable. In this case, our data have only two years represented, so we will treat these two years as “groups” or categories. brfss$Year &lt;- factor(brfss$Year) Let’s make a couple of subsets of data to work with. First, let’s subset to get only males in 2010. brfss2010Male = subset(brfss,Sex==&#39;Male&#39; &amp; Year==&#39;2010&#39;) and make an “only female” subset. brfssFemale = subset(brfss,Sex==&#39;Female&#39;) ```r ggplot(brfss2010Male, aes(x=Height, y=Weight)) + geom_point() + geom_smooth(method=&quot;lm&quot;) ``` &lt;img src=&quot;D2_IO_files/figure-html/unnamed-chunk-5-1.png&quot; width=&quot;70%&quot; style=&quot;display: block; margin: auto;&quot; /&gt; Capture a plot and augment it plt &lt;- ggplot(brfss2010Male, aes(x=Height, y=Weight)) + geom_point() + geom_smooth(method=&quot;lm&quot;) plt + labs(title = &quot;2010 Male&quot;) Use facet_*() for layouts ggplot(brfssFemale, aes(x=Height, y=Weight)) + geom_point() + geom_smooth(method=&quot;lm&quot;) + facet_grid(. ~ Year) Choose display to emphasize relevant aspects of data ggplot(brfssFemale, aes(Weight, fill=Year)) + geom_density(alpha=.2) 8.2 ALL Phenotypic Data This data comes from an (old) Acute Lymphoid Leukemia microarray data set. The actual data are available at THIS LINK or by downloading using R. download.file(&#39;https://raw.githubusercontent.com/seandavi/ITR/master/ALL-phenoData.csv&#39;, destfile = &#39;ALL-phenoData.csv&#39;) Choose the file that contains ALL (acute lymphoblastic leukemia) patient information and input the date using read.csv(); for read.csv(), use row.names=1 to indicate that the first column contains row names. path &lt;- file.choose() # look for ALL-phenoData.csv stopifnot(file.exists(path)) pdata &lt;- read.csv(path, row.names=1) Check out the help page ?read.delim for input options. The exercises use ?read.csv; Can you guess why? Explore basic properties of the object you’ve created, for instance… class(pdata) ## [1] &quot;data.frame&quot; colnames(pdata) ## [1] &quot;cod&quot; &quot;diagnosis&quot; &quot;sex&quot; &quot;age&quot; ## [5] &quot;BT&quot; &quot;remission&quot; &quot;CR&quot; &quot;date.cr&quot; ## [9] &quot;t.4.11.&quot; &quot;t.9.22.&quot; &quot;cyto.normal&quot; &quot;citog&quot; ## [13] &quot;mol.biol&quot; &quot;fusion.protein&quot; &quot;mdr&quot; &quot;kinet&quot; ## [17] &quot;ccr&quot; &quot;relapse&quot; &quot;transplant&quot; &quot;f.u&quot; ## [21] &quot;date.last.seen&quot; dim(pdata) ## [1] 128 21 head(pdata) ## cod diagnosis sex age BT remission CR date.cr t.4.11. t.9.22. ## 01005 1005 5/21/1997 M 53 B2 CR CR 8/6/1997 FALSE TRUE ## 01010 1010 3/29/2000 M 19 B2 CR CR 6/27/2000 FALSE FALSE ## 03002 3002 6/24/1998 F 52 B4 CR CR 8/17/1998 NA NA ## 04006 4006 7/17/1997 M 38 B1 CR CR 9/8/1997 TRUE FALSE ## 04007 4007 7/22/1997 M 57 B2 CR CR 9/17/1997 FALSE FALSE ## 04008 4008 7/30/1997 M 17 B1 CR CR 9/27/1997 FALSE FALSE ## cyto.normal citog mol.biol fusion.protein mdr kinet ccr ## 01005 FALSE t(9;22) BCR/ABL p210 NEG dyploid FALSE ## 01010 FALSE simple alt. NEG &lt;NA&gt; POS dyploid FALSE ## 03002 NA &lt;NA&gt; BCR/ABL p190 NEG dyploid FALSE ## 04006 FALSE t(4;11) ALL1/AF4 &lt;NA&gt; NEG dyploid FALSE ## 04007 FALSE del(6q) NEG &lt;NA&gt; NEG dyploid FALSE ## 04008 FALSE complex alt. NEG &lt;NA&gt; NEG hyperd. FALSE ## relapse transplant f.u date.last.seen ## 01005 FALSE TRUE BMT / DEATH IN CR &lt;NA&gt; ## 01010 TRUE FALSE REL 8/28/2000 ## 03002 TRUE FALSE REL 10/15/1999 ## 04006 TRUE FALSE REL 1/23/1998 ## 04007 TRUE FALSE REL 11/4/1997 ## 04008 TRUE FALSE REL 12/15/1997 summary(pdata$sex) ## F M NA&#39;s ## 42 83 3 summary(pdata$cyto.normal) ## Mode FALSE TRUE NA&#39;s ## logical 69 24 35 Remind yourselves about various ways to subset and access columns of a data.frame pdata[1:5, 3:4] ## sex age ## 01005 M 53 ## 01010 M 19 ## 03002 F 52 ## 04006 M 38 ## 04007 M 57 pdata[1:5, ] ## cod diagnosis sex age BT remission CR date.cr t.4.11. t.9.22. ## 01005 1005 5/21/1997 M 53 B2 CR CR 8/6/1997 FALSE TRUE ## 01010 1010 3/29/2000 M 19 B2 CR CR 6/27/2000 FALSE FALSE ## 03002 3002 6/24/1998 F 52 B4 CR CR 8/17/1998 NA NA ## 04006 4006 7/17/1997 M 38 B1 CR CR 9/8/1997 TRUE FALSE ## 04007 4007 7/22/1997 M 57 B2 CR CR 9/17/1997 FALSE FALSE ## cyto.normal citog mol.biol fusion.protein mdr kinet ccr ## 01005 FALSE t(9;22) BCR/ABL p210 NEG dyploid FALSE ## 01010 FALSE simple alt. NEG &lt;NA&gt; POS dyploid FALSE ## 03002 NA &lt;NA&gt; BCR/ABL p190 NEG dyploid FALSE ## 04006 FALSE t(4;11) ALL1/AF4 &lt;NA&gt; NEG dyploid FALSE ## 04007 FALSE del(6q) NEG &lt;NA&gt; NEG dyploid FALSE ## relapse transplant f.u date.last.seen ## 01005 FALSE TRUE BMT / DEATH IN CR &lt;NA&gt; ## 01010 TRUE FALSE REL 8/28/2000 ## 03002 TRUE FALSE REL 10/15/1999 ## 04006 TRUE FALSE REL 1/23/1998 ## 04007 TRUE FALSE REL 11/4/1997 head(pdata[, 3:5]) ## sex age BT ## 01005 M 53 B2 ## 01010 M 19 B2 ## 03002 F 52 B4 ## 04006 M 38 B1 ## 04007 M 57 B2 ## 04008 M 17 B1 tail(pdata[, 3:5], 3) ## sex age BT ## 65003 M 30 T3 ## 83001 M 29 T2 ## LAL4 &lt;NA&gt; NA T head(pdata$age) ## [1] 53 19 52 38 57 17 head(pdata$sex) ## [1] M M F M M M ## Levels: F M head(pdata[pdata$age &gt; 21,]) ## cod diagnosis sex age BT remission CR date.cr t.4.11. t.9.22. ## 01005 1005 5/21/1997 M 53 B2 CR CR 8/6/1997 FALSE TRUE ## 03002 3002 6/24/1998 F 52 B4 CR CR 8/17/1998 NA NA ## 04006 4006 7/17/1997 M 38 B1 CR CR 9/8/1997 TRUE FALSE ## 04007 4007 7/22/1997 M 57 B2 CR CR 9/17/1997 FALSE FALSE ## 08001 8001 1/15/1997 M 40 B2 CR CR 3/26/1997 FALSE FALSE ## 08011 8011 8/21/1998 M 33 B3 CR CR 10/8/1998 FALSE FALSE ## cyto.normal citog mol.biol fusion.protein mdr kinet ccr ## 01005 FALSE t(9;22) BCR/ABL p210 NEG dyploid FALSE ## 03002 NA &lt;NA&gt; BCR/ABL p190 NEG dyploid FALSE ## 04006 FALSE t(4;11) ALL1/AF4 &lt;NA&gt; NEG dyploid FALSE ## 04007 FALSE del(6q) NEG &lt;NA&gt; NEG dyploid FALSE ## 08001 FALSE del(p15) BCR/ABL p190 NEG &lt;NA&gt; FALSE ## 08011 FALSE del(p15/p16) BCR/ABL p190/p210 NEG dyploid FALSE ## relapse transplant f.u date.last.seen ## 01005 FALSE TRUE BMT / DEATH IN CR &lt;NA&gt; ## 03002 TRUE FALSE REL 10/15/1999 ## 04006 TRUE FALSE REL 1/23/1998 ## 04007 TRUE FALSE REL 11/4/1997 ## 08001 TRUE FALSE REL 7/11/1997 ## 08011 FALSE TRUE BMT / DEATH IN CR &lt;NA&gt; It seems from below that there are 17 females over 40 in the data set. However, some individuals have NA for the age and / or sex, and these NA values propagate through some computations. Use table() to summarize the number of females over 40, and the number of samples for which this classification cannot be determined. When R encounters an NA value in a subscript index, it introduces an NA into the result. Observe this (rows of NA values introduced into the result) when subsetting using [ versus using the subset() function. idx &lt;- pdata$sex == &quot;F&quot; &amp; pdata$age &gt; 40 table(idx, useNA=&quot;ifany&quot;) ## idx ## FALSE TRUE &lt;NA&gt; ## 108 17 3 dim(pdata[idx,]) # WARNING: &#39;NA&#39; rows introduced ## [1] 20 21 tail(pdata[idx,]) ## cod diagnosis sex age BT remission CR ## 49006 49006 8/12/1998 F 43 B2 CR CR ## 57001 57001 1/29/1997 F 53 B3 &lt;NA&gt; DEATH IN INDUCTION ## 62001 62001 11/11/1997 F 50 B4 REF REF ## NA.1 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; NA &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 02020 2020 3/23/2000 F 48 T2 &lt;NA&gt; DEATH IN INDUCTION ## NA.2 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; NA &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## date.cr t.4.11. t.9.22. cyto.normal citog mol.biol ## 49006 11/19/1998 NA NA NA &lt;NA&gt; BCR/ABL ## 57001 &lt;NA&gt; FALSE FALSE TRUE normal NEG ## 62001 &lt;NA&gt; FALSE TRUE FALSE t(9;22)+other BCR/ABL ## NA.1 &lt;NA&gt; NA NA NA &lt;NA&gt; &lt;NA&gt; ## 02020 &lt;NA&gt; FALSE FALSE FALSE complex alt. NEG ## NA.2 &lt;NA&gt; NA NA NA &lt;NA&gt; &lt;NA&gt; ## fusion.protein mdr kinet ccr relapse transplant f.u ## 49006 p210 NEG dyploid FALSE TRUE FALSE REL ## 57001 &lt;NA&gt; NEG hyperd. NA NA NA &lt;NA&gt; ## 62001 &lt;NA&gt; NEG hyperd. NA NA NA &lt;NA&gt; ## NA.1 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; NA NA NA &lt;NA&gt; ## 02020 &lt;NA&gt; NEG dyploid NA NA NA &lt;NA&gt; ## NA.2 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; NA NA NA &lt;NA&gt; ## date.last.seen ## 49006 4/26/1999 ## 57001 &lt;NA&gt; ## 62001 &lt;NA&gt; ## NA.1 &lt;NA&gt; ## 02020 &lt;NA&gt; ## NA.2 &lt;NA&gt; dim(subset(pdata, idx)) # BETTER: no NA rows ## [1] 17 21 dim(subset(pdata, (sex == &quot;F&quot;) &amp; (age &gt; 40))) # alternative ## [1] 17 21 tail(subset(pdata,idx)) ## cod diagnosis sex age BT remission CR date.cr ## 28032 28032 9/26/1998 F 52 B1 CR CR 10/30/1998 ## 30001 30001 1/16/1997 F 54 B3 &lt;NA&gt; DEATH IN INDUCTION &lt;NA&gt; ## 49006 49006 8/12/1998 F 43 B2 CR CR 11/19/1998 ## 57001 57001 1/29/1997 F 53 B3 &lt;NA&gt; DEATH IN INDUCTION &lt;NA&gt; ## 62001 62001 11/11/1997 F 50 B4 REF REF &lt;NA&gt; ## 02020 2020 3/23/2000 F 48 T2 &lt;NA&gt; DEATH IN INDUCTION &lt;NA&gt; ## t.4.11. t.9.22. cyto.normal citog mol.biol fusion.protein ## 28032 TRUE FALSE FALSE t(4;11) ALL1/AF4 &lt;NA&gt; ## 30001 FALSE TRUE FALSE t(9;22)+other BCR/ABL p190 ## 49006 NA NA NA &lt;NA&gt; BCR/ABL p210 ## 57001 FALSE FALSE TRUE normal NEG &lt;NA&gt; ## 62001 FALSE TRUE FALSE t(9;22)+other BCR/ABL &lt;NA&gt; ## 02020 FALSE FALSE FALSE complex alt. NEG &lt;NA&gt; ## mdr kinet ccr relapse transplant f.u date.last.seen ## 28032 NEG dyploid TRUE FALSE FALSE CCR 5/16/2002 ## 30001 NEG hyperd. NA NA NA &lt;NA&gt; &lt;NA&gt; ## 49006 NEG dyploid FALSE TRUE FALSE REL 4/26/1999 ## 57001 NEG hyperd. NA NA NA &lt;NA&gt; &lt;NA&gt; ## 62001 NEG hyperd. NA NA NA &lt;NA&gt; &lt;NA&gt; ## 02020 NEG dyploid NA NA NA &lt;NA&gt; &lt;NA&gt; ## robust `[`: exclude NA values dim(pdata[idx &amp; !is.na(idx),]) ## [1] 17 21 Use the mol.biol column to subset the data to contain just individuals with ‘BCR/ABL’ or ‘NEG’, e.g., bcrabl &lt;- subset(pdata, mol.biol %in% c(&quot;BCR/ABL&quot;, &quot;NEG&quot;)) The mol.biol column is a factor, and retains all levels even after subsetting. It is sometimes convenient to retain factor levels, but in our case we use droplevels() to removed unused levels bcrabl$mol.biol &lt;- droplevels(bcrabl$mol.biol) The BT column is a factor describing B- and T-cell subtypes levels(bcrabl$BT) ## [1] &quot;B&quot; &quot;B1&quot; &quot;B2&quot; &quot;B3&quot; &quot;B4&quot; &quot;T&quot; &quot;T1&quot; &quot;T2&quot; &quot;T3&quot; &quot;T4&quot; How might one collapse B1, B2, … to a single type B, and likewise for T1, T2, …, so there are only two subtypes, B and T? One strategy is to replace two-letter level (e.g., B1) with the single-letter level (e.g., B). Do this using substring() to select the first letter of level, and update the previous levels with the new value using levels&lt;-. table(bcrabl$BT) ## ## B B1 B2 B3 B4 T T1 T2 T3 T4 ## 4 9 35 22 9 5 1 15 9 2 levels(bcrabl$BT) &lt;- substring(levels(bcrabl$BT), 1, 1) table(bcrabl$BT) ## ## B T ## 79 32 Use aggregate() to count the number of samples with B- and T-cell types in each of the BCR/ABL and NEG groups aggregate(rownames(bcrabl) ~ BT + mol.biol, bcrabl, length) ## BT mol.biol rownames(bcrabl) ## 1 B BCR/ABL 37 ## 2 B NEG 42 ## 3 T NEG 32 Use aggregate() to calculate the average age of males and females in the BCR/ABL and NEG treatment groups. aggregate(age ~ mol.biol + sex, bcrabl, mean) ## mol.biol sex age ## 1 BCR/ABL F 39.9 ## 2 NEG F 30.4 ## 3 BCR/ABL M 40.5 ## 4 NEG M 27.2 Use t.test() to compare the age of individuals in the BCR/ABL versus NEG groups; visualize the results using boxplot(). In both cases, use the formula interface. Consult the help page ?t.test and re-do the test assuming that variance of ages in the two groups is identical. What parts of the test output change? t.test(age ~ mol.biol, bcrabl) ## ## Welch Two Sample t-test ## ## data: age by mol.biol ## t = 5, df = 70, p-value = 8e-06 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## 7.14 17.22 ## sample estimates: ## mean in group BCR/ABL mean in group NEG ## 40.2 28.1 boxplot(age ~ mol.biol, bcrabl) "],
["exploration-and-simple-univariate-measures.html", "9 Exploration and simple univariate measures 9.1 Clean data 9.2 Weight in 1990 vs. 2010 Females 9.3 Weight and height in 2010 Males", " 9 Exploration and simple univariate measures path &lt;- file.choose() # look for BRFSS-subset.csv stopifnot(file.exists(path)) brfss &lt;- read.csv(path) 9.1 Clean data R read Year as an integer value, but it’s really a factor brfss$Year &lt;- factor(brfss$Year) 9.2 Weight in 1990 vs. 2010 Females Create a subset of the data brfssFemale &lt;- brfss[brfss$Sex == &quot;Female&quot;,] summary(brfssFemale) ## Age Weight Sex Height Year ## Min. :18.0 Min. : 36 Female:12039 Min. :105 1990:5718 ## 1st Qu.:37.0 1st Qu.: 58 Male : 0 1st Qu.:158 2010:6321 ## Median :52.0 Median : 66 Median :163 ## Mean :51.9 Mean : 69 Mean :163 ## 3rd Qu.:67.0 3rd Qu.: 77 3rd Qu.:168 ## Max. :99.0 Max. :272 Max. :201 ## NA&#39;s :103 NA&#39;s :560 NA&#39;s :140 Visualize plot(Weight ~ Year, brfssFemale) Statistical test t.test(Weight ~ Year, brfssFemale) ## ## Welch Two Sample t-test ## ## data: Weight by Year ## t = -30, df = 10000, p-value &lt;2e-16 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## -8.72 -7.55 ## sample estimates: ## mean in group 1990 mean in group 2010 ## 64.8 73.0 9.3 Weight and height in 2010 Males Create a subset of the data brfss2010Male &lt;- subset(brfss, Year == 2010 &amp; Sex == &quot;Male&quot;) summary(brfss2010Male) ## Age Weight Sex Height Year ## Min. :18.0 Min. : 36.3 Female: 0 Min. :135 1990: 0 ## 1st Qu.:45.0 1st Qu.: 77.1 Male :3679 1st Qu.:173 2010:3679 ## Median :57.0 Median : 86.2 Median :178 ## Mean :56.2 Mean : 88.8 Mean :178 ## 3rd Qu.:68.0 3rd Qu.: 99.8 3rd Qu.:183 ## Max. :99.0 Max. :279.0 Max. :218 ## NA&#39;s :30 NA&#39;s :49 NA&#39;s :31 Visualize the relationship hist(brfss2010Male$Weight) hist(brfss2010Male$Height) plot(Weight ~ Height, brfss2010Male) Fit a linear model (regression) fit &lt;- lm(Weight ~ Height, brfss2010Male) fit ## ## Call: ## lm(formula = Weight ~ Height, data = brfss2010Male) ## ## Coefficients: ## (Intercept) Height ## -86.875 0.987 Summarize as ANOVA table anova(fit) ## Analysis of Variance Table ## ## Response: Weight ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## Height 1 197664 197664 694 &lt;2e-16 *** ## Residuals 3617 1030484 285 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Plot points, superpose fitted regression line; where am I? plot(Weight ~ Height, brfss2010Male) abline(fit, col=&quot;blue&quot;, lwd=2) points(180, 88, col=&quot;red&quot;, cex=4, pch=20) Class and available ‘methods’ class(fit) # &#39;noun&#39; methods(class=class(fit)) # &#39;verb&#39; Diagnostics plot(fit) ?plot.lm "],
["multivariate-analysis.html", "10 Multivariate analysis 10.1 Input and setup 10.2 Cleaning 10.3 Unsupervised machine learning – multi-dimensional scaling", " 10 Multivariate analysis This is a classic microarray experiment. Microarrays consist of ‘probesets’ that interogate genes for their level of expression. In the experiment we’re looking at, there are 12625 probesets measured on each of the 128 samples. The raw expression levels estimated by microarray assays require considerable pre-processing, the data we’ll work with has been pre-processed. 10.1 Input and setup Start by finding the expression data file on disk. path &lt;- file.choose() # look for ALL-expression.csv stopifnot(file.exists(path)) The data is stored in ‘comma-separate value’ format, with each probeset occupying a line, and the expression value for each sample in that probeset separated by a comma. Input the data using read.csv(). There are three challenges: The row names are present in the first column of the data. Tell R this by adding the argument row.names=1 to read.csv(). By default, R checks that column names do not look like numbers, but our column names do look like numbers. Use the argument check.colnames=FALSE to over-ride R’s default. read.csv() returns a data.frame. We could use a data.frame to work with our data, but really it is a matrix() – the columns are of the same type and measure the same thing. Use as.matrix() to coerce the data.frame we input to a matrix. exprs &lt;- read.csv(path, row.names=1, check.names=FALSE) exprs &lt;- as.matrix(exprs) class(exprs) ## [1] &quot;matrix&quot; dim(exprs) ## [1] 12625 128 exprs[1:6, 1:10] ## 01005 01010 03002 04006 04007 04008 04010 04016 06002 08001 ## 1000_at 7.60 7.48 7.57 7.38 7.91 7.07 7.47 7.54 7.18 7.74 ## 1001_at 5.05 4.93 4.80 4.92 4.84 5.15 5.12 5.02 5.29 4.63 ## 1002_f_at 3.90 4.21 3.89 4.21 3.42 3.95 4.15 3.58 3.90 3.63 ## 1003_s_at 5.90 6.17 5.86 6.12 5.69 6.21 6.29 5.67 5.84 5.88 ## 1004_at 5.93 5.91 5.89 6.17 5.62 5.92 6.05 5.74 5.99 5.75 ## 1005_at 8.57 10.43 9.62 9.94 9.98 10.06 10.66 11.27 8.81 10.17 range(exprs) ## [1] 1.98 14.13 We’ll make use of the data describing the samples path &lt;- file.choose() # look for ALL-phenoData.csv stopifnot(file.exists(path)) pdata &lt;- read.csv(path, row.names=1) class(pdata) ## [1] &quot;data.frame&quot; dim(pdata) ## [1] 128 21 head(pdata) ## cod diagnosis sex age BT remission CR date.cr t.4.11. t.9.22. ## 01005 1005 5/21/1997 M 53 B2 CR CR 8/6/1997 FALSE TRUE ## 01010 1010 3/29/2000 M 19 B2 CR CR 6/27/2000 FALSE FALSE ## 03002 3002 6/24/1998 F 52 B4 CR CR 8/17/1998 NA NA ## 04006 4006 7/17/1997 M 38 B1 CR CR 9/8/1997 TRUE FALSE ## 04007 4007 7/22/1997 M 57 B2 CR CR 9/17/1997 FALSE FALSE ## 04008 4008 7/30/1997 M 17 B1 CR CR 9/27/1997 FALSE FALSE ## cyto.normal citog mol.biol fusion.protein mdr kinet ccr ## 01005 FALSE t(9;22) BCR/ABL p210 NEG dyploid FALSE ## 01010 FALSE simple alt. NEG &lt;NA&gt; POS dyploid FALSE ## 03002 NA &lt;NA&gt; BCR/ABL p190 NEG dyploid FALSE ## 04006 FALSE t(4;11) ALL1/AF4 &lt;NA&gt; NEG dyploid FALSE ## 04007 FALSE del(6q) NEG &lt;NA&gt; NEG dyploid FALSE ## 04008 FALSE complex alt. NEG &lt;NA&gt; NEG hyperd. FALSE ## relapse transplant f.u date.last.seen ## 01005 FALSE TRUE BMT / DEATH IN CR &lt;NA&gt; ## 01010 TRUE FALSE REL 8/28/2000 ## 03002 TRUE FALSE REL 10/15/1999 ## 04006 TRUE FALSE REL 1/23/1998 ## 04007 TRUE FALSE REL 11/4/1997 ## 04008 TRUE FALSE REL 12/15/1997 Some of the results below involve plots, and it’s convenient to choose pretty and functional colors. We use the RColorBrewer package; see colorbrewer.org library(RColorBrewer) ## not available? install package via RStudio highlight &lt;- brewer.pal(3, &quot;Set2&quot;)[1:2] `highlight’ is a vector of length 2, light and dark green. For more options see ?RColorBrewer and to view the predefined palettes display.brewer.all() 10.2 Cleaning We’ll add a column to pdata, derived from the BT column, to indicate whether the sample is B-cell or T-cell ALL. pdata$BorT &lt;- factor(substr(pdata$BT, 1, 1)) Microarray expression data is usually represented as a matrix of genes as rows and samples as columns. Statisticians usually think of their data as samples as rows, features as columns. So we’ll transpose the expression values exprs &lt;- t(exprs) Confirm that the pdata rows correspond to the exprs rows. stopifnot(identical(rownames(pdata), rownames(exprs))) 10.3 Unsupervised machine learning – multi-dimensional scaling Reduce high-dimensional data to lower dimension for visualization. Calculate distance between samples (requires that the expression matrix be transposed). d &lt;- dist(exprs) Use the cmdscale() function to summarize the distance matrix into two points in two dimensions. cmd &lt;- cmdscale(d) Visualize the result, coloring points by B- or T-cell status plot(cmd, col=highlight[pdata$BorT]) "],
["using-r-in-real-life.html", "11 Using R in real life 11.1 Organizing work 11.2 R Packages", " 11 Using R in real life 11.1 Organizing work Usually, work is organized into a directory with: A folder containing R scripts (scripts/BRFSS-visualize.R) ‘External’ data like the csv files that we’ve been working with, usually in a separate folder (extdata/BRFSS-subset.csv) (sometimes) R objects written to disk using saveRDS() (.rds files) that represent final results or intermediate ‘checkpoints’ (extdata/ALL-cleaned.rds). Read the data into an R session using readRDS(). Use setwd() to navigate to folder containing scripts/, extdata/ folder Source an entire script with source(&quot;scripts/BRFSS-visualization.R&quot;). R can also save the state of the current session (prompt when choosing to quit() R), and to view and save the history() of the the current session; I do not find these to be helpful in my own work flows. 11.2 R Packages All the functionality we have been using comes from packages that are automatically loaded when R starts. Loaded packages are on the search() path. search() ## [1] &quot;.GlobalEnv&quot; &quot;package:stats&quot; &quot;package:graphics&quot; ## [4] &quot;package:grDevices&quot; &quot;package:utils&quot; &quot;package:datasets&quot; ## [7] &quot;Autoloads&quot; &quot;package:base&quot; Additional packages may be installed in R’s libraries. Use `installed.packages() or the RStudio interface to see installed packages. To use these packages, it is necessary to attach them to the search path, e.g., for survival analysis library(&quot;survival&quot;) There are many thousands of R packages, and not all of them are installed in a single installation. Important repositories are CRAN: https://cran.r-project.org/ Bioconductor: https://bioconductor.org/packages Packages can be discovered in various ways, including CRAN Task Views and the Bioconductor web and Bioconductor support sites. To install a package, use install.packages() or, for Bioconductor packages, instructions on the package landing page, e.g., for GenomicRanges. Here we install the ggplot2 package. install.packages(&quot;ggplot2&quot;, repos=&quot;https://cran.r-project.org&quot;) A package needs to be installed once, and then can be used in any R session. "],
["graphics-and-visualization.html", "12 Graphics and Visualization 12.1 Base R Graphics 12.2 What makes for a good graphical display? 12.3 Grammar of Graphics: ggplot2", " 12 Graphics and Visualization Load the BRFSS-subset.csv data path &lt;- &quot;BRFSS-subset.csv&quot; # or file.choose() brfss &lt;- read.csv(path) Clean it by coercing Year to factor brfss$Year &lt;- factor(brfss$Year) 12.1 Base R Graphics Useful for quick exploration during a normal work flow. Main functions: plot(), hist(), boxplot(), … Graphical parameters – see ?par, but often provided as arguments to plot(), etc. Construct complicated plots by layering information, e.g., points, regression line, annotation. brfss2010Male &lt;- subset(brfss, (Year == 2010) &amp; (Sex == &quot;Male&quot;)) fit &lt;- lm(Weight ~ Height, brfss2010Male) plot(Weight ~ Height, brfss2010Male, main=&quot;2010, Males&quot;) abline(fit, lwd=2, col=&quot;blue&quot;) points(180, 90, pch=20, cex=3, col=&quot;red&quot;) Approach to complicated graphics: create a grid of panels (e.g., par(mfrows=c(1, 2)), populate with plots, restore original layout. brfssFemale &lt;- subset(brfss, Sex==&quot;Female&quot;) opar = par(mfrow=c(2, 1)) # layout: 2 &#39;rows&#39; and 1 &#39;column&#39; hist( # first panel -- 1990 brfssFemale[ brfssFemale$Year == 1990, &quot;Weight&quot; ], main = &quot;Female, 1990&quot;) hist( # second panel -- 2010 brfssFemale[ brfssFemale$Year == 2010, &quot;Weight&quot; ], main = &quot;Female, 2010&quot;) par(opar) # restore original layout 12.2 What makes for a good graphical display? Common scales for comparison Efficient use of space Careful color choice – qualitative, gradient, divergent schemes; color blind aware; … Emphasis on data rather than labels Convey statistical uncertainty 12.3 Grammar of Graphics: ggplot2 library(ggplot2) http://docs.ggplot2.org ‘Grammar of graphics’ Specify data and ‘aesthetics’ (aes()) to be plotted Add layers (geom_*()) of information ggplot(brfss2010Male, aes(x=Height, y=Weight)) + geom_point() + geom_smooth(method=&quot;lm&quot;) Capture a plot and augment it plt &lt;- ggplot(brfss2010Male, aes(x=Height, y=Weight)) + geom_point() + geom_smooth(method=&quot;lm&quot;) plt + labs(title = &quot;2010 Male&quot;) Use facet_*() for layouts ggplot(brfssFemale, aes(x=Height, y=Weight)) + geom_point() + geom_smooth(method=&quot;lm&quot;) + facet_grid(. ~ Year) Choose display to emphasize relevant aspects of data ggplot(brfssFemale, aes(Weight, fill=Year)) + geom_density(alpha=.2) "],
["examples.html", "13 Examples 13.1 GEOquery to multidimensional scaling", " 13 Examples 13.1 GEOquery to multidimensional scaling Data containers–SummarizedExperiment Use the GEOquery package to fetch data about GSE103512. library(GEOquery) gse = getGEO(&quot;GSE103512&quot;)[[1]] gse ## ExpressionSet (storageMode: lockedEnvironment) ## assayData: 54715 features, 280 samples ## element names: exprs ## protocolData: none ## phenoData ## sampleNames: GSM2772660 GSM2772661 ... GSM2772939 (280 total) ## varLabels: title geo_accession ... weight:ch1 (73 total) ## varMetadata: labelDescription ## featureData ## featureNames: 1007_PM_s_at 1053_PM_at ... AFFX-TrpnX-M_at (54715 ## total) ## fvarLabels: ID GB_ACC ... Gene Ontology Molecular Function (16 ## total) ## fvarMetadata: Column Description labelDescription ## experimentData: use &#39;experimentData(object)&#39; ## Annotation: GPL13158 Examine two variables of interest, cancer type and tumor/normal status. with(pData(gse),table(`cancer type:ch1`,`normal:ch1`)) ## normal:ch1 ## cancer type:ch1 no yes ## BC 65 10 ## CRC 57 12 ## NSCLC 60 9 ## PCA 60 7 Information about features measured are also included. Gene Symbol Gene Title 1007_PM_s_at DDR1 discoidin domain receptor tyrosine kinase 1 1053_PM_at RFC2 replication factor C (activator 1) 2, 40kDa 117_PM_at HSPA6 heat shock 70kDa protein 6 (HSP70B’) 121_PM_at PAX8 paired box 8 1255_PM_g_at GUCA1A guanylate cyclase activator 1A (retina) 1294_PM_at UBA7 ubiquitin-like modifier activating enzyme 7 ENTREZ_GENE_ID 1007_PM_s_at 780 1053_PM_at 5982 117_PM_at 3310 121_PM_at 7849 1255_PM_g_at 2978 1294_PM_at 7318 Filter gene expression by variance to find most informative genes. sds = apply(exprs(gse),1,sd) dat = exprs(gse)[order(sds,decreasing = TRUE)[1:500],] Perform multidimensional scaling and prepare for plotting. mdsvals = cmdscale(dist(t(dat))) mdsvals = as.data.frame(mdsvals) mdsvals$Type=factor(pData(gse)[,&#39;cancer type:ch1&#39;]) mdsvals$Normal = factor(pData(gse)[,&#39;normal:ch1&#39;]) And do the plot. library(ggplot2) ggplot(mdsvals, aes(x=V1,y=V2,shape=Normal,color=Type)) + geom_point( alpha=0.6) + theme(text=element_text(size = 18)) "],
["appendix-data-sets.html", "A Appendix – Data Sets", " A Appendix – Data Sets BRFSS subset ALL clinical data ALL expression data "],
["appendix-swirl.html", "B Appendix – Swirl", " B Appendix – Swirl The following is from the swirl website. The swirl R package makes it fun and easy to learn R programming and data science. If you are new to R, have no fear. To get started, we need to install a new package into R. install.packages(&#39;swirl&#39;) Once installed, we want to load it into the R workspace so we can use it. library(&#39;swirl&#39;) Finally, to get going, start swirl and follow the instructions. swirl() "]
]
