[
["index.html", "Introduction to R (ITR) 1 Why R? 1.1 What is R? 1.2 Why use R? 1.3 Why not use R? 1.4 R License and the Open Source Ideal", " Introduction to R (ITR) Using the Bioconductor Ranges Infrastructure Sean Davis 6/29/2017 1 Why R? 1.1 What is R? R is a number of things, simultaneously. Depending on who is being asked, R is: A software package A programming language A toolkit for developing statistical and analytical tools An extensive library of statistical and mathematical software and algorithms A scripting language much, much more 1.2 Why use R? R is cross-platform and runs on Windows, Mac, and Linux (as well as more obscure systems). R provides a vast number of useful statistical tools, many of which have been painstakingly tested. R produces publication-quality graphics in a variety of formats. R plays well with FORTRAN, C, and scripts in many languages. R scales, making it useful for small and large projects. It is NOT Excel. R does not have a meaningfully useful graphical user interface (GUI). I can develop code for analysis on my Mac laptop. I can then install the same code on our 20k core cluster and run it in parallel on 100 samples, monitor the process, and then update a database (for example) with R when complete. 1.3 Why not use R? R cannot do everything. R is not always the “best” tool for the job. R will not hold your hand. Often, it will slap your hand instead. The documentation can be opaque (but there is documentation). R can drive you crazy (on a good day) or age you prematurely (on a bad one). Finding the right package to do the job you want to do can be challenging; worse, some contributed packages are unreliable.]{} R does not have a meaningfully useful graphical user interface (GUI). 1.4 R License and the Open Source Ideal R is free (yes, totally free!) and distributed under GNU license. In particular, this license allows one to: Download the source code Modify the source code to your heart’s content Distribute the modified source code and even charge money for it, but you must distribute the modified source code under the original GNU license]{} This license means that R will always be available, will always be open source, and can grow organically without constraint. "],
["r-mechanics.html", "2 R Mechanics 2.1 Installing R 2.2 Starting R", " 2 R Mechanics 2.1 Installing R The home page for R is called the Comprehensive R Archive Network (CRAN). The website is not pretty (see figure 2.1), but it has quite a bit of information on it. It is not the best place to find help on R, although it is one of the best places to get R-related software, tools, and updates. knitr::include_graphics(&#39;images/CRAN-screenshot.png&#39;) Figure 2.1: The Comprehensive R Archive Network (CRAN) website Detailed installation instructions are readily available, but here are abbreviated instructions for convenience. 2.1.1 Windows NOTE: See Windows installation instructions for more detail. Install R and RStudio as regular users. To install R, visit the Windows base distribution page. Click on the Download R-3.4.0 for Windows link (or use the latest version available). Click on the installer and make the default selection for each option. To install RStudio, visit the RStudio download page. Click on the current RStudio release for Windows link. Click on the installer and follow default instructions. 2.1.2 Mac NOTE: See R for Mac OS X for more detail. To install R, visit the R for Mac OS X. Click on the the R-3.4.0.pkg link (or use the latest version available). Click on the installer and follow default instructions. To install RStudio, visit the RStudio download page. Click on the current RStudio release for Windows link. Click on the installer and follow default instructions. 2.1.3 Linux NOTE: See distribution-specific instructions for additional detail. On debian-based systems, the easiest way to install R is through a package manager manager, run under an administrator account. On Linux one usually needs to install R packages from source, and R package source often contains C, C++, or Fortran code requiring a compiler and -dev versions of various system libraries. It is therefore convenient to install the -dev version of R. sudo apt-get install r-base r-base-dev When installing source packages, it may be necessary to have access to the -dev version of various system libraries. Many of these are installed as dependencies of r-base-dev; other common examples include the xml and curl libraries sudo apt-get install libxml2-dev sudo apt-get install libcurl-dev Note in particular the use specification of libraries (the lib prefix) and the use of the -dev version. To install RStudio, visit the RStudio download page. Download the appropriate archive for your OS. On Ubuntu, install the .deb installer with sudo dpkg -i rstudio-1.0.136-amd64.deb 2.2 Starting R How to start R depends a bit on the operating system (Mac, Windows, Linux) and interface. In this course, we will largely be using an Integrated Development Environment (IDE) called RStudio, but there is nothing to prohibit using R at the command line or in some other interface (and there are a few). A screenshot of the interface is shown in figure 2.2. Figure 2.2: The Rstudio interface "],
["first-steps.html", "3 First steps 3.1 Interacting with R 3.2 Rules for Names in R 3.3 Resources for Getting Help", " 3 First steps 3.1 Interacting with R The only meaningful way of interacting with R is by typing into the R console. At the most basic level, anything that we type at the command line will fall into one of two categories: Assignments x = 1 y &lt;- 2 Expressions 1 + pi + sin(42) ## [1] 3.225071 The assignment type is obvious because either the The “&lt;-” or “=” are used. Note that when we type expressions, R will return a result. In this case, the result of R evaluating 1 + pi + sin(42) is 3.2250711. The standard R prompt is a “&gt;” sign. When present, R is waiting for the next expression or assignment. If a line is not a complete R command, R will continue the next line with a “+”. For example, typing the fillowing with a “Return” after the second “+” will result in R giving back a “+” on the next line, a prompt to keep typing. 1 + pi + sin(3.7) ## [1] 3.611757 3.2 Rules for Names in R R allows users to assign names to objects such as variables, functions, and even dimensions of data. However, these names must follow a few rules. Names may contain any combination of letters, numbers, underscore, and “.” Names may not start with numbers, underscore. R names are case-sensitive. Examples of valid R names include: pi x camelCaps my_stuff MY_Stuff this.is.the.name.of.the.man ABC123 abc1234asdf .hi 3.3 Resources for Getting Help There is extensive built-in help and documentation within R. If the name of the function or object on which help is sought is known, the following approaches with the name of the function or object will be helpful. For a concrete example, examine the help for the print method. help(print) help(&#39;print&#39;) ?print If the name of the function or object on which help is sought is not known, the following from within R will be helpful. help.search(&#39;microarray&#39;) RSiteSearch(&#39;microarray&#39;) There are also tons of online resources that Google will include in searches if online searching feels more appropriate. I strongly recommend using help(newfunction) for all functions that are new or unfamiliar to you. "],
["introduction-to-r-data-structures.html", "4 Introduction to R data structures 4.1 Vectors 4.2 Rectangular Data 4.3 Lists and Objects", " 4 Introduction to R data structures As in many programming languages, understanding how data are stored and manipulated is important to getting the most out of the experience. In these next few sections, we will introduce some basic R data types and structures as well as some general approaches for working with them. 4.1 Vectors In R, even a single value is a vector with length=1. z = 1 z ## [1] 1 length(z) ## [1] 1 In the code above, we “assigned” the value 1 to the variable named z. Typing z by itself is an “expression” that returns a result which is, in this case, the value that we just assigned. The length method takes an R object and returns the R length. There are numerous ways of asking R about what an object represents, and length is one of them. Vectors can contain numbers, strings (character data), or logical values (TRUE and FALSE) or other “atomic” data types (table 4.1). Vectors cannot contain a mix of types! We will introduce another data structure, the R list for situations when we need to store a mix of base R data types. Table 4.1: Atomic (simplest) data types in R. Data type Stores numeric floating point numbers integer integers complex complex numbers factor categorical data character strings logical TRUE or FALSE NA missing NULL empty function function type 4.1.1 Creating vectors Character vectors (also sometimes called “string” vectors) are entered with each value surrounded by single or double quotes; either is acceptable, but they must match. They are always displayed by R with double quotes. Here are some examples of creating vectors: # examples of vectors c(&#39;hello&#39;,&#39;world&#39;) ## [1] &quot;hello&quot; &quot;world&quot; c(1,3,4,5,1,2) ## [1] 1 3 4 5 1 2 c(1.12341e7,78234.126) ## [1] 11234100.00 78234.13 c(TRUE,FALSE,TRUE,TRUE) ## [1] TRUE FALSE TRUE TRUE # note how in the next case the TRUE is converted to &quot;TRUE&quot; # with quotes around it. c(TRUE,&#39;hello&#39;) ## [1] &quot;TRUE&quot; &quot;hello&quot; We can also create vectors as “regular sequences” of numbers. For example: # create a vector of integers from 1 to 10 x = 1:10 # and backwards x = 10:1 The seq function can create more flexible regular sequences. # create a vector of numbers from 1 to 4 skipping by 0.3 y = seq(1,4,0.3) And creating a new vector by concatenating existing vectors is possible, as well. # create a sequence by concatenating two other sequences z = c(y,x) z ## [1] 1.0 1.3 1.6 1.9 2.2 2.5 2.8 3.1 3.4 3.7 4.0 10.0 9.0 8.0 ## [15] 7.0 6.0 5.0 4.0 3.0 2.0 1.0 4.1.2 Vector Operations Operations on a single vector are typically done element-by-element. For example, we can add 2 to a vector, 2 is added to each element of the vector and a new vector of the same length is returned. x = 1:10 x + 2 ## [1] 3 4 5 6 7 8 9 10 11 12 If the operation involves two vectors, the following rules apply. If the vectors are the same length: R simply applies the operation to each pair of elements. x + x ## [1] 2 4 6 8 10 12 14 16 18 20 If the vectors are different lengths, but one length a multiple of the other, R reuses the shorter vector as needed. x = 1:10 y = c(1,2) x * y ## [1] 1 4 3 8 5 12 7 16 9 20 If the vectors are different lengths, but one length not a multiple of the other, R reuses the shorter vector as needed and delivers a warning. x = 1:10 y = c(2,3,4) x * y ## Warning in x * y: longer object length is not a multiple of shorter object ## length ## [1] 2 6 12 8 15 24 14 24 36 20 Typical operations include multiplication (“*”), addition, subtraction, division, exponentiation (“^”), but many operations in R operate on vectors and are then called “vectorized”. 4.1.3 Logical Vectors Logical vectors are vectors composed on only the values TRUE and FALSE. Note the all-upper-case and no quotation marks. a = c(TRUE,FALSE,TRUE) # we can also create a logical vector from a numeric vector # 0 = false, everything else is 1 b = c(1,0,217) d = as.logical(b) d ## [1] TRUE FALSE TRUE # test if a and d are the same at every element all.equal(a,d) ## [1] TRUE # We can also convert from logical to numeric as.numeric(a) ## [1] 1 0 1 4.1.4 Logical Operators Some operators like &lt;, &gt;, ==, &gt;=, &lt;=, != can be used to create logical vectors. # create a numeric vector x = 1:10 # testing whether x &gt; 5 creates a logical vector x &gt; 5 ## [1] FALSE FALSE FALSE FALSE FALSE TRUE TRUE TRUE TRUE TRUE x &lt;= 5 ## [1] TRUE TRUE TRUE TRUE TRUE FALSE FALSE FALSE FALSE FALSE x != 5 ## [1] TRUE TRUE TRUE TRUE FALSE TRUE TRUE TRUE TRUE TRUE x == 5 ## [1] FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE We can also assign the results to a variable: y = (x == 5) y ## [1] FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE 4.1.5 Indexing Vectors In R, an index is used to refer to a specific element or set of elements in an vector (or other data structure). [R uses [ and ] to perform indexing, although other approaches to getting subsets of larger data structures are common in R. x = seq(0,1,0.1) # create a new vector from the 4th element of x x[4] ## [1] 0.3 We can even use other vectors to perform the “indexing”. x[c(3,5,6)] ## [1] 0.2 0.4 0.5 y = 3:6 x[y] ## [1] 0.2 0.3 0.4 0.5 Combining the concept of indexing with the concept of logical vectors results in a very power combination. # use help(&#39;rnorm&#39;) to figure out what is happening next myvec = rnorm(10) # create logical vector that is TRUE where myvec is &gt;0.25 gt1 = (myvec &gt; 0.25) sum(gt1) ## [1] 5 # and use our logical vector to create a vector of myvec values that are &gt;0.25 myvec[gt1] ## [1] 0.5207375 0.4624359 1.4290447 0.7855104 2.1671228 # or &lt;=0.25 using the logical &quot;not&quot; operator, &quot;!&quot; myvec[!gt1] ## [1] -0.40374789 -0.24775144 -0.49599618 -0.04671779 -1.46392097 # shorter, one line approach myvec[myvec &gt; 0.25] ## [1] 0.5207375 0.4624359 1.4290447 0.7855104 2.1671228 4.1.6 Character Vectors, A.K.A. Strings R uses the paste function to concatenate strings. paste(&quot;abc&quot;,&quot;def&quot;) ## [1] &quot;abc def&quot; paste(&quot;abc&quot;,&quot;def&quot;,sep=&quot;THISSEP&quot;) ## [1] &quot;abcTHISSEPdef&quot; paste0(&quot;abc&quot;,&quot;def&quot;) ## [1] &quot;abcdef&quot; ## [1] &quot;abcdef&quot; paste(c(&quot;X&quot;,&quot;Y&quot;),1:10) ## [1] &quot;X 1&quot; &quot;Y 2&quot; &quot;X 3&quot; &quot;Y 4&quot; &quot;X 5&quot; &quot;Y 6&quot; &quot;X 7&quot; &quot;Y 8&quot; &quot;X 9&quot; &quot;Y 10&quot; paste(c(&quot;X&quot;,&quot;Y&quot;),1:10,sep=&quot;_&quot;) ## [1] &quot;X_1&quot; &quot;Y_2&quot; &quot;X_3&quot; &quot;Y_4&quot; &quot;X_5&quot; &quot;Y_6&quot; &quot;X_7&quot; &quot;Y_8&quot; &quot;X_9&quot; &quot;Y_10&quot; We can count the number of characters in a string. nchar(&#39;abc&#39;) ## [1] 3 nchar(c(&#39;abc&#39;,&#39;d&#39;,123456)) ## [1] 3 1 6 Pulling out parts of strings is also sometimes useful. substr(&#39;This is a good sentence.&#39;,start=10,stop=15) ## [1] &quot; good &quot; Another common operation is to replace something in a string with something (a find-and-replace). sub(&#39;This&#39;,&#39;That&#39;,&#39;This is a good sentence.&#39;) ## [1] &quot;That is a good sentence.&quot; When we want to find all strings that match some other string, we can use grep, or “grab regular expression”. grep(&#39;bcd&#39;,c(&#39;abcdef&#39;,&#39;abcd&#39;,&#39;bcde&#39;,&#39;cdef&#39;,&#39;defg&#39;)) ## [1] 1 2 3 grep(&#39;bcd&#39;,c(&#39;abcdef&#39;,&#39;abcd&#39;,&#39;bcde&#39;,&#39;cdef&#39;,&#39;defg&#39;),value=TRUE) ## [1] &quot;abcdef&quot; &quot;abcd&quot; &quot;bcde&quot; 4.1.7 Missing Values, AKA “NA” R has a special value, “NA”, that represents a “missing” value, or Not Available, in a vector or other data structure. Here, we just create a vector to experiment. x = 1:5 x ## [1] 1 2 3 4 5 length(x) ## [1] 5 is.na(x) ## [1] FALSE FALSE FALSE FALSE FALSE x[2] = NA x ## [1] 1 NA 3 4 5 The length of x is unchanged, but there is one value that is marked as “missing” by virtue of being NA. length(x) ## [1] 5 is.na(x) ## [1] FALSE TRUE FALSE FALSE FALSE We can remove NA values by using indexing. In the following, is.na(x) returns a logical vector the length of x. The ! is the logical NOT operator and converts TRUE to FALSE and vice-versa. x[!is.na(x)] ## [1] 1 3 4 5 4.1.8 Factors A factor is a special type of vector, normally used to hold a categorical variable–such as smoker/nonsmoker, state of residency, zipcode–in many statistical functions. Such vectors have class “factor”. Factors are primarily used in Analysis of Variance (ANOVA) or other situations when “categories” are needed. When a factor is used as a predictor variable, the corresponding indicator variables are created (more later). Note of caution that factors in R often appear to be character vectors when printed, but you will notice that they do not have double quotes around them. They are stored in R as numbers with a key name, so sometimes you will note that the factor behaves like a numeric vector. # create the character vector citizen&lt;-c(&quot;uk&quot;,&quot;us&quot;,&quot;no&quot;,&quot;au&quot;,&quot;uk&quot;,&quot;us&quot;,&quot;us&quot;,&quot;no&quot;,&quot;au&quot;) # convert to factor citizenf&lt;-factor(citizen) citizen ## [1] &quot;uk&quot; &quot;us&quot; &quot;no&quot; &quot;au&quot; &quot;uk&quot; &quot;us&quot; &quot;us&quot; &quot;no&quot; &quot;au&quot; citizenf ## [1] uk us no au uk us us no au ## Levels: au no uk us # convert factor back to character vector as.character(citizenf) ## [1] &quot;uk&quot; &quot;us&quot; &quot;no&quot; &quot;au&quot; &quot;uk&quot; &quot;us&quot; &quot;us&quot; &quot;no&quot; &quot;au&quot; # convert to numeric vector as.numeric(citizenf) ## [1] 3 4 2 1 3 4 4 2 1 R stores many data structures as vectors with “attributes” and “class” (just so you have seen this). attributes(citizenf) ## $levels ## [1] &quot;au&quot; &quot;no&quot; &quot;uk&quot; &quot;us&quot; ## ## $class ## [1] &quot;factor&quot; class(citizenf) ## [1] &quot;factor&quot; # note that after unclassing, we can see the # underlying numeric structure again unclass(citizenf) ## [1] 3 4 2 1 3 4 4 2 1 ## attr(,&quot;levels&quot;) ## [1] &quot;au&quot; &quot;no&quot; &quot;uk&quot; &quot;us&quot; Tabulating factors is a useful way to get a sense of the “sample” set available. table(citizenf) ## citizenf ## au no uk us ## 2 2 2 3 4.2 Rectangular Data A matrix is a rectangular collection of the same data type. It can be viewed as a collection of column vectors all of the same length and the same type (i.e. numeric, character or logical). A data.frame is also a rectangular array. All of the columns must be the same length, but they may be of different types. The rows and columns of a matrix or data frame can be given names. However these are implemented differently in R; many operations will work for one but not both, often a source of confusion. 4.2.1 Matrices We start by building a matrix from parts: x &lt;- 1:10 y &lt;- rnorm(10) # make a matrix by column binding two numeric vectors mat&lt;-cbind(x,y) mat ## x y ## [1,] 1 -1.1325129 ## [2,] 2 0.9527356 ## [3,] 3 0.4940566 ## [4,] 4 -0.4485334 ## [5,] 5 -1.0842092 ## [6,] 6 -1.3726937 ## [7,] 7 -0.7361857 ## [8,] 8 0.9787948 ## [9,] 9 -1.3248857 ## [10,] 10 1.2943944 Inspecting the names associated with rows and columns is often useful, particularly if the names have human meaning. rownames(mat) ## NULL colnames(mat) ## [1] &quot;x&quot; &quot;y&quot; Matrices have dimensions. dim(mat) ## [1] 10 2 nrow(mat) ## [1] 10 ncol(mat) ## [1] 2 Indexing for matrices works as for vectors except that we now need to include both the row and column (in that order). # The 2nd element of the 1st row of mat mat[1,2] ## y ## -1.132513 # The first ROW of mat mat[1,] ## x y ## 1.000000 -1.132513 # The first COLUMN of mat mat[,1] ## [1] 1 2 3 4 5 6 7 8 9 10 # and all elements of mat that are &gt; 4; note no comma mat[mat&gt;4] ## [1] 5 6 7 8 9 10 ## [1] 5 6 7 8 9 10 Note that in the last case, there is no “,”, so R treats the matrix as a long vector (length=20). This is convenient, sometimes, but it can also be a source of error, as some code may “work” but be doing something unexpected. In the next example, we create a matrix with 2 columns and 10 rows. m = matrix(rnorm(20),nrow=10) # multiply all values in the matrix by 20 m = m*20 # and add 100 to the first column of m m[,1] = m[,1] + 100 # summarize m summary(m) ## V1 V2 ## Min. : 67.15 Min. :-20.262 ## 1st Qu.: 87.57 1st Qu.: -6.269 ## Median : 91.78 Median : 7.028 ## Mean : 93.30 Mean : 5.840 ## 3rd Qu.:100.98 3rd Qu.: 16.416 ## Max. :117.47 Max. : 28.441 4.2.2 Data Frames 4.2.2.1 Matrices Versus Data Frames mat&lt;-cbind(x,y) head(mat) ## x y ## [1,] 1 -1.1325129 ## [2,] 2 0.9527356 ## [3,] 3 0.4940566 ## [4,] 4 -0.4485334 ## [5,] 5 -1.0842092 ## [6,] 6 -1.3726937 class(mat[,1]) ## [1] &quot;numeric&quot; z = paste0(&#39;a&#39;,1:10) tab&lt;-cbind(x,y,z) class(tab) ## [1] &quot;matrix&quot; mode(tab[,1]) ## [1] &quot;character&quot; head(tab,4) ## x y z ## [1,] &quot;1&quot; &quot;-1.1325128934989&quot; &quot;a1&quot; ## [2,] &quot;2&quot; &quot;0.95273561440436&quot; &quot;a2&quot; ## [3,] &quot;3&quot; &quot;0.494056643357164&quot; &quot;a3&quot; ## [4,] &quot;4&quot; &quot;-0.448533411804648&quot; &quot;a4&quot; tab&lt;-data.frame(x,y,z) class(tab) ## [1] &quot;data.frame&quot; head(tab) ## x y z ## 1 1 -1.1325129 a1 ## 2 2 0.9527356 a2 ## 3 3 0.4940566 a3 ## 4 4 -0.4485334 a4 ## 5 5 -1.0842092 a5 ## 6 6 -1.3726937 a6 mode(tab[,1]) ## [1] &quot;numeric&quot; class(tab[,3]) ## [1] &quot;factor&quot; rownames(tab) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; rownames(tab)&lt;-paste0(&quot;row&quot;,1:10) rownames(tab) ## [1] &quot;row1&quot; &quot;row2&quot; &quot;row3&quot; &quot;row4&quot; &quot;row5&quot; &quot;row6&quot; &quot;row7&quot; &quot;row8&quot; ## [9] &quot;row9&quot; &quot;row10&quot; Data frame columns can be refered to by name using the “dollar sign” operator. head(tab) ## x y z ## row1 1 -1.1325129 a1 ## row2 2 0.9527356 a2 ## row3 3 0.4940566 a3 ## row4 4 -0.4485334 a4 ## row5 5 -1.0842092 a5 ## row6 6 -1.3726937 a6 tab$x ## [1] 1 2 3 4 5 6 7 8 9 10 tab$y ## [1] -1.1325129 0.9527356 0.4940566 -0.4485334 -1.0842092 -1.3726937 ## [7] -0.7361857 0.9787948 -1.3248857 1.2943944 Column names can be set, which can be useful for referring to data later. colnames(tab) ## [1] &quot;x&quot; &quot;y&quot; &quot;z&quot; colnames(tab) = paste0(&#39;col&#39;,1:3) Data frames have functions to report size and even summary functions. Try the following: ncol(tab) ## [1] 3 nrow(tab) ## [1] 10 dim(tab) ## [1] 10 3 summary(tab) ## col1 col2 col3 ## Min. : 1.00 Min. :-1.3727 a1 :1 ## 1st Qu.: 3.25 1st Qu.:-1.1204 a10 :1 ## Median : 5.50 Median :-0.5924 a2 :1 ## Mean : 5.50 Mean :-0.2379 a3 :1 ## 3rd Qu.: 7.75 3rd Qu.: 0.8381 a4 :1 ## Max. :10.00 Max. : 1.2944 a5 :1 ## (Other):4 Extracting parts of a data.frame work as for matrices. Try to think about what each of the following will do before asking R to evaluate the result. tab[1:3,] ## col1 col2 col3 ## row1 1 -1.1325129 a1 ## row2 2 0.9527356 a2 ## row3 3 0.4940566 a3 tab[,2:3] ## col2 col3 ## row1 -1.1325129 a1 ## row2 0.9527356 a2 ## row3 0.4940566 a3 ## row4 -0.4485334 a4 ## row5 -1.0842092 a5 ## row6 -1.3726937 a6 ## row7 -0.7361857 a7 ## row8 0.9787948 a8 ## row9 -1.3248857 a9 ## row10 1.2943944 a10 tab[,1]&gt;7 ## [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE TRUE TRUE tab[tab[,1]&gt;7,] ## col1 col2 col3 ## row8 8 0.9787948 a8 ## row9 9 -1.3248857 a9 ## row10 10 1.2943944 a10 tab[tab[,1]&gt;7,3] ## [1] a8 a9 a10 ## Levels: a1 a10 a2 a3 a4 a5 a6 a7 a8 a9 tab[tab[,1]&gt;7,2:3] ## col2 col3 ## row8 0.9787948 a8 ## row9 -1.3248857 a9 ## row10 1.2943944 a10 tab[tab$x&gt;7,3] ## factor(0) ## Levels: a1 a10 a2 a3 a4 a5 a6 a7 a8 a9 tab$z[tab$x&gt;3] ## NULL 4.3 Lists and Objects A list is a collection of objects that may be the same or different types. The objects in a list often have names, and may be indexed either by name (e.g. my_list$name3) or component number (e.g. my_list[[3]]). As an aside, a data frame is a list of matched column vectors. We can reate a list, noting the different data types involved. a = list(1,&quot;b&quot;,c(1,2,3)) a ## [[1]] ## [1] 1 ## ## [[2]] ## [1] &quot;b&quot; ## ## [[3]] ## [1] 1 2 3 length(a) ## [1] 3 class(a) ## [1] &quot;list&quot; a[[3]] ## [1] 1 2 3 A data frame is a list. # test if our friend &quot;tab&quot; is a list is.list(tab) ## [1] TRUE tab[[2]] ## [1] -1.1325129 0.9527356 0.4940566 -0.4485334 -1.0842092 -1.3726937 ## [7] -0.7361857 0.9787948 -1.3248857 1.2943944 names(tab) ## [1] &quot;col1&quot; &quot;col2&quot; &quot;col3&quot; Table (#tab:datatypes) Summary of basic R data structures. Data type S tores vector one-dimensional data, single data type matrix two-dimensional data, single data type data frame two-dimensional data, multiple data types list list of data types, not all need to be the same type object a list with attributes and potentially slots and methods "],
["plotting-and-graphics.html", "5 Plotting and Graphics 5.1 Basic Plot Functions", " 5 Plotting and Graphics Visit these sites for some ideas. http://www.sr.bham.ac.uk/~ajrs/R/r-gallery.html http://gallery.r-enthusiasts.com/ http://cran.r-project.org/web/views/Graphics.html 5.1 Basic Plot Functions The command plot(x,y) will plot vector x as the independent variable and vector y as the dependent variable. Within the command line, you can specify the title of the graph, the name of the x-axis, and the name of the y-axis. - main=’title’ - xlab=’name of x axis’ - ylab=’name of y axis’ The command lines(x,y) adds a line segment to an existing plot. The command points(x,y) adds points to the plot. A legend can be created using legend, though getting the legend right for base graphics can be a bit challenging. To get a basic idea of what R offers, it has a build-in demo that can be run with demo(graphics). 5.1.1 Simple Plotting Example Try this yourself: x = 1:100 y = rnorm(100,3,1) # 100 random normal deviates with mean=3, sd=1 plot(x,y) plot(x,y,main=&#39;My First Plot&#39;) # change point type plot(x,y,pch=3) # change color plot(x,y,pch=4,col=2) # draw lines between points lines(x,y,col=3) z=sort(y) # plot a sorted variable vs x plot(x,z,main=&#39;Random Normal Numbers&#39;, xlab=&#39;Index&#39;,ylab=&#39;Random Number&#39;) # A basic histogram hist(z, main=&quot;Histogram&quot;, sub=&quot;Random normal&quot;) # A &quot;density&quot; plot plot(density(z), main=&quot;Density plot&quot;, sub=&quot;Random normal&quot;) # A smaller &quot;bandwidth&quot; to capture more detail plot(density(z, adjust=0.5), sub=&quot;smaller bandwidth&quot;) 5.1.2 Graphics Devices and Saving Plots To make a plot directly to a file use: png(), postscript(), etc. png(file=&quot;myplot.png&quot;,width=480,height=480) plot(density(z,adjust=2.0),sub=&quot;larger bandwidth&quot;) dev.off() ## quartz_off_screen ## 2 On your own, save a pdf to a file. NOTE: The dimensions in pdf() are in inches. To put multiple plots on a page, we can set the mfrow graphics parameter. par(mfrow=c(2,1)) plot(density(z,adjust=2.0),sub=&quot;larger bandwidth&quot;) hist(z) # use dev.off() to turn off the two-row plotting R can have multiple graphics “devices” open. To see a list of active devices: dev.list() To close the most recent device: dev.off() To close device 5: dev.off(5) To use device 5: dev.set(5) "],
["plotting-with-ggplot2.html", "6 Plotting with ggplot2 6.1 mtcars data 6.2 NYC Flight data", " 6 Plotting with ggplot2 The ggplot2 package is a relatively novel approach to generating highly informative publication-quality graphics. The “gg” stands for “Grammar of Graphics”. In short, instead of thinking about a single function that produces a plot, ggplot2 uses a “grammar” approach, akin to building more and more complex sentences to layer on more information or nuance. See the ggplot2 graphics gallery for some examples with accompanying code. The ggplot2 package assumes that data are in the form of a data.frame. In some cases, the data will need to be manipulated into a form that matches assumptions that ggplot2 uses. In particular, if one has a matrix of numbers associated with different subjects (samples, people, etc.), the data will usually need to be transformed into a “long” data frame. To use the ggplot2 package, it must be installed and loaded. Assuming that installation has been done already, we can load the package directly: library(ggplot2) 6.1 mtcars data We are going to use the mtcars dataset, included with R, to experiment with ggplot2. data(mtcars) Exercise: Explore the mtcars dataset using View, summary, dim, class, etc. We can also take a quick look at the relationships between the variables using the pairs plotting function. pairs(mtcars) That is a useful view of the data. We want to use ggplot2 to make an informative plot, so let’s approach this in a piecewise fashion. We first need to decide what type of plot to produce and what our basic variables will be. In this case, we have a number of choices. ggplot(mtcars,aes(x=disp,y=hp)) First, a little explanation is necessary. The ggplot function takes as its first argument a data.frame. The second argument is the “aesthetic”, aes. The x and y take column names from the mtcars data.frame and will form the basis of our scatter plot. But why did we get that “Error: No layers in plot”? Remember that ggplot2 is a “grammar of graphics”. We supplied a subject, but no verb (called a layer by ggplot2). So, to generate a plot, we need to supply a verb. There are many possibilities. Each “verb” or layer typically starts with “geom” and then a descriptor. An example is necessary. ggplot(mtcars,aes(x=disp,y=hp)) + geom_point() We finally produced a plot. The power of ggplot2, though, is the ability to make very rich plots by adding “grammar” to the “plot sentence”. We have a number of other variables in our mtcars data.frame. How can we add another value to a two-dimensional plot? ggplot(mtcars,aes(x=disp,y=hp,color=cyl)) + geom_point() The color of the points is a based on the numeric variable wt, the weight of the car. Can we do more? We can change the size of the points, also. ggplot(mtcars,aes(x=disp,y=hp,color=wt,size=mpg)) + geom_point() So, on our 2D plot, we are now plotting four variables. Can we do more? We can manipulate the shape of the points in addition to the color and the size. ggplot(mtcars,aes(x=disp,y=hp)) + geom_point(aes(size=mpg,color=wt,shape=cyl)) Why did we get that error? Ggplot2 is trying to be helpful by telling us that a “continuous varialbe cannot be mapped to ‘shape’”. Well, in our mtcars data.frame, we can look at cyl in detail. class(mtcars$cyl) ## [1] &quot;numeric&quot; summary(mtcars$cyl) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 4.000 4.000 6.000 6.188 8.000 8.000 table(mtcars$cyl) ## ## 4 6 8 ## 11 7 14 The cyl variable is “kinda” continuous in that it is numeric, but it could also be thought of as a “category” of engines. R has a specific data type for “category” data, called a factor. We can easily convert the cyl column to a factor like so: mtcars$cyl = as.factor(mtcars$cyl) Now, we can go ahead with our previous approach to make a 2-dimensional plot that displays the relationships between five variables. ggplot(mtcars,aes(x=disp,y=hp)) + geom_point(aes(size=mpg,color=wt,shape=cyl)) 6.1.1 Additional exercises Use geom_text to add labels to your plot. Convert all your work to plotly for interactive versions of the plots. 6.2 NYC Flight data I leave this section open-ended for you to explore further options with the ggplot2 package. The data represent the on-time data for all flights that departed New York City in 2013. # install.packages(&#39;nycflights13&#39;) library(nycflights13) data(flights) head(flights) ## # A tibble: 6 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 ## 2 2013 1 1 533 529 4 850 ## 3 2013 1 1 542 540 2 923 ## 4 2013 1 1 544 545 -1 1004 ## 5 2013 1 1 554 600 -6 812 ## 6 2013 1 1 554 558 -4 740 ## # ... with 12 more variables: sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, ## # time_hour &lt;dttm&gt; Use ggplot and other plotting tools to explore the data and look for features that might contribute to airport delays. Consider using other “geoms” during your exploration. "],
["control-structures-looping-and-applying.html", "7 Control Structures, Looping, and Applying 7.1 Control Structures and Looping 7.2 Applying", " 7 Control Structures, Looping, and Applying 7.1 Control Structures and Looping 7.1.1 Control Structures in R R has multiple types of control structures that allows for sequential evaluation of statements. For loops for (x in set) {operations} while loops while (x in condition){operations} If statements (conditional) if (condition) { some operations } else { other operations } 7.1.2 Control Structure and Looping Examples x&lt;-1:9 length(x) # a simple conditional then two expressions if (length(x)&lt;=10) { x&lt;-c(x,10:20);print(x)} # more complex if (length(x)&lt;5) { print(x) } else { print(x[5:20]) } # print the values of x, one at a time for (i in x) print(i) for(i in x) i # note R will not echo in a loop 7.1.3 Control Structure and Looping Examples # loop over a character vector y&lt;-c(&#39;a&#39;,&#39;b&#39;,&#39;hi there&#39;) for (i in y) print(i) # and a while loop j&lt;-1 while(j&lt;10) { # do this while j&lt;10 print(j) j&lt;-j+2} # at each iteration, increase j by 2 7.2 Applying 7.2.1 Why Does R Have Apply Functions Often we want to apply the same function to all the rows or columns of a matrix, or all the elements of a list. We could do this in a loop, but loops take a lot of time in an interpreted language like R. R has more efficient built-in operators, the apply functions. example If mat is a matrix and fun is a function (such as mean, var, lm …) that takes a vector as its argument, then you can: apply(mat,1,fun) # over rows--second argument is 1 apply(mat,2,fun) # over columns--second argument is 2 In either case, the output is a vector. 7.2.2 Apply Function Exercise Using the matrix and rnorm functions, create a matrix with 20 rows and 10 columns (200 values total) of random normal deviates. Compute the mean for each row of the matrix. Compute the median for each column. 7.2.3 Related Apply Functions lapply(list, function) applies the function to every element of list sapply(list or vector, function) applies the function to every element of list or vector, and returns a vector, when possible (easier to process) tapply(x, factor, fun) uses the factor to split vector x into groups, and then applies fun to each group 7.2.4 Related Apply Function Examples # create a list my.list &lt;- list(a=1:3,b=5:10,c=11:20) my.list # Get the mean for each member of the list # return a vector sapply( my.list, mean) # Get the full summary for each member of # the list, returned as a list lapply( my.list, summary) # Find the mean for each group defined by a factor my.vector &lt;- 1:10 my.factor &lt;- factor( c(1,1,1,2,2,2,3,3,3,3)) tapply(my.vector, my.factor, mean) "],
["functions.html", "8 Functions", " 8 Functions 8.0.1 Function Overview Functions are objects and are assigned to names, just like data. myFunction = function(argument1,argument2) { expression1 expression2 } We write functions for anything we need to do again and again. You may test your commands interactively at first, and then use the history() feature and an editor to create the function. It is wise to include a comment at the start of each function to say what it does and to document functions of more than a few lines. 8.0.2 Example Functions add1 = function(x) { # this function adds one to the first argument and returns it x + 1 } add1(17) ## [1] 18 add1(c(17,18,19,20)) ## [1] 18 19 20 21 You can use the edit() function to make changes to a function. The following command will open a window, allow you to make changes, and assign the result to a new function, add2. add2 = edit(add1) 8.0.3 Further Reading The amount of learning material for R is simply astonishing! Thomas Girke’s R and Bioconductor Manual A HUGE collection of contributed R documentation and tutorials Bioconductor course materials Sean Davis’ website The Official R Manuals "],
["data-input-and-exploration.html", "9 Data Input and Exploration 9.1 Behavioral Risk Factor Surveillance System 9.2 ALL Phenotypic Data", " 9 Data Input and Exploration 9.1 Behavioral Risk Factor Surveillance System We will explore a subset of data collected by the CDC through its extensive Behavioral Risk Factor Surveillance System (BRFSS) telephone survey. Check out the link for more information. We’ll look at a subset of the data. First, we need to get the data. Either download the data from THIS LINK or have R do it directly from the command-line (preferred): download.file(&#39;https://raw.githubusercontent.com/seandavi/ITR/master/BRFSS-subset.csv&#39;, destfile = &#39;BRFSS-subset.csv&#39;) You can check to see the file using the Rstudio file panel or get a directory listing using dir() Use file.choose() to find the path to the file ‘BRFSS-subset.csv’ path &lt;- file.choose() Read the data into R using read.csv(), assigning to a variable brfss. brfss &lt;- read.csv(path) Use command like class(), head(), dim(), summary() to explore the data. What variables have been measured? Can you guess at the units used for, e.g., Weight and Height? class(brfss) head(brfss) dim(brfss) summary(brfss) Use the $ operator to extract the ‘Sex’ column, and summarize the number of males and females in the survey using table(). Do the same for ‘Year’, and for both Sex and Year table(brfss$Sex) ## ## Female Male ## 12039 7961 table(brfss$Year) ## ## 1990 2010 ## 10000 10000 table(brfss$Sex, brfss$Year) ## ## 1990 2010 ## Female 5718 6321 ## Male 4282 3679 with(brfss, table(Sex, Year)) # same, but easier ## Year ## Sex 1990 2010 ## Female 5718 6321 ## Male 4282 3679 Use aggregate() to summarize the mean weight of each group. What about the median weight of each group? What about the number of observations in each group? with(brfss, aggregate(Weight, list(Year, Sex), mean, na.rm=TRUE)) ## Group.1 Group.2 x ## 1 1990 Female 64.81838 ## 2 2010 Female 72.95424 ## 3 1990 Male 81.17999 ## 4 2010 Male 88.84657 with(brfss, aggregate(Weight, list(Year=Year, Sex=Sex), mean, na.rm=TRUE)) ## Year Sex x ## 1 1990 Female 64.81838 ## 2 2010 Female 72.95424 ## 3 1990 Male 81.17999 ## 4 2010 Male 88.84657 Use a formula and the aggregate() function to describe the relationship between Year, Sex, and Weight aggregate(Weight ~ Year + Sex, brfss, mean) # same, but more informative ## Year Sex Weight ## 1 1990 Female 64.81838 ## 2 2010 Female 72.95424 ## 3 1990 Male 81.17999 ## 4 2010 Male 88.84657 aggregate(. ~ Year + Sex, brfss, mean) # all variables ## Year Sex Age Weight Height ## 1 1990 Female 46.09153 64.84333 163.2914 ## 2 2010 Female 57.07807 73.03178 163.2469 ## 3 1990 Male 43.87574 81.19496 178.2242 ## 4 2010 Male 56.25465 88.91136 178.0139 Create a subset of the data consisting of only the 1990 observations. Perform a t-test comparing the weight of males and females (“‘Weight’ as a function of ‘Sex’”, Weight ~ Sex) brfss_1990 = brfss[brfss$Year == 1990,] t.test(Weight ~ Sex, brfss_1990) ## ## Welch Two Sample t-test ## ## data: Weight by Sex ## t = -58.734, df = 9214, p-value &lt; 2.2e-16 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## -16.90767 -15.81554 ## sample estimates: ## mean in group Female mean in group Male ## 64.81838 81.17999 t.test(Weight ~ Sex, brfss, subset = Year == 1990) ## ## Welch Two Sample t-test ## ## data: Weight by Sex ## t = -58.734, df = 9214, p-value &lt; 2.2e-16 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## -16.90767 -15.81554 ## sample estimates: ## mean in group Female mean in group Male ## 64.81838 81.17999 What about differences between weights of males (or females) in 1990 versus 2010? Check out the help page ?t.test.formula. Is there a way of performing a t-test on brfss without explicitly creating the object brfss_1990? Use boxplot() to plot the weights of the Male individuals. Can you transform weight, e.g., sqrt(Weight) ~ Year? Interpret the results. Do similar boxplots for the t-tests of the previous question. boxplot(Weight ~ Year, brfss, subset = Sex == &quot;Male&quot;, main=&quot;Males&quot;) Use hist() to plot a histogram of weights of the 1990 Female individuals. hist(brfss_1990[brfss_1990$Sex == &quot;Female&quot;, &quot;Weight&quot;], main=&quot;Females, 1990&quot;, xlab=&quot;Weight&quot; ) 9.2 ALL Phenotypic Data This data comes from an (old) Acute Lymphoid Leukemia microarray data set. The actual data are available at THIS LINK or by downloading using R. download.file(&#39;https://raw.githubusercontent.com/seandavi/ITR/master/ALL-phenoData.csv&#39;, destfile = &#39;ALL-phenoData.csv&#39;) Choose the file that contains ALL (acute lymphoblastic leukemia) patient information and input the date using read.csv(); for read.csv(), use row.names=1 to indicate that the first column contains row names. path &lt;- file.choose() # look for ALL-phenoData.csv stopifnot(file.exists(path)) pdata &lt;- read.csv(path, row.names=1) Check out the help page ?read.delim for input options. The exercises use ?read.csv; Can you guess why? Explore basic properties of the object you’ve created, for instance… class(pdata) ## [1] &quot;data.frame&quot; colnames(pdata) ## [1] &quot;cod&quot; &quot;diagnosis&quot; &quot;sex&quot; &quot;age&quot; ## [5] &quot;BT&quot; &quot;remission&quot; &quot;CR&quot; &quot;date.cr&quot; ## [9] &quot;t.4.11.&quot; &quot;t.9.22.&quot; &quot;cyto.normal&quot; &quot;citog&quot; ## [13] &quot;mol.biol&quot; &quot;fusion.protein&quot; &quot;mdr&quot; &quot;kinet&quot; ## [17] &quot;ccr&quot; &quot;relapse&quot; &quot;transplant&quot; &quot;f.u&quot; ## [21] &quot;date.last.seen&quot; dim(pdata) ## [1] 128 21 head(pdata) ## cod diagnosis sex age BT remission CR date.cr t.4.11. t.9.22. ## 01005 1005 5/21/1997 M 53 B2 CR CR 8/6/1997 FALSE TRUE ## 01010 1010 3/29/2000 M 19 B2 CR CR 6/27/2000 FALSE FALSE ## 03002 3002 6/24/1998 F 52 B4 CR CR 8/17/1998 NA NA ## 04006 4006 7/17/1997 M 38 B1 CR CR 9/8/1997 TRUE FALSE ## 04007 4007 7/22/1997 M 57 B2 CR CR 9/17/1997 FALSE FALSE ## 04008 4008 7/30/1997 M 17 B1 CR CR 9/27/1997 FALSE FALSE ## cyto.normal citog mol.biol fusion.protein mdr kinet ccr ## 01005 FALSE t(9;22) BCR/ABL p210 NEG dyploid FALSE ## 01010 FALSE simple alt. NEG &lt;NA&gt; POS dyploid FALSE ## 03002 NA &lt;NA&gt; BCR/ABL p190 NEG dyploid FALSE ## 04006 FALSE t(4;11) ALL1/AF4 &lt;NA&gt; NEG dyploid FALSE ## 04007 FALSE del(6q) NEG &lt;NA&gt; NEG dyploid FALSE ## 04008 FALSE complex alt. NEG &lt;NA&gt; NEG hyperd. FALSE ## relapse transplant f.u date.last.seen ## 01005 FALSE TRUE BMT / DEATH IN CR &lt;NA&gt; ## 01010 TRUE FALSE REL 8/28/2000 ## 03002 TRUE FALSE REL 10/15/1999 ## 04006 TRUE FALSE REL 1/23/1998 ## 04007 TRUE FALSE REL 11/4/1997 ## 04008 TRUE FALSE REL 12/15/1997 summary(pdata$sex) ## F M NA&#39;s ## 42 83 3 summary(pdata$cyto.normal) ## Mode FALSE TRUE NA&#39;s ## logical 69 24 35 Remind yourselves about various ways to subset and access columns of a data.frame pdata[1:5, 3:4] ## sex age ## 01005 M 53 ## 01010 M 19 ## 03002 F 52 ## 04006 M 38 ## 04007 M 57 pdata[1:5, ] ## cod diagnosis sex age BT remission CR date.cr t.4.11. t.9.22. ## 01005 1005 5/21/1997 M 53 B2 CR CR 8/6/1997 FALSE TRUE ## 01010 1010 3/29/2000 M 19 B2 CR CR 6/27/2000 FALSE FALSE ## 03002 3002 6/24/1998 F 52 B4 CR CR 8/17/1998 NA NA ## 04006 4006 7/17/1997 M 38 B1 CR CR 9/8/1997 TRUE FALSE ## 04007 4007 7/22/1997 M 57 B2 CR CR 9/17/1997 FALSE FALSE ## cyto.normal citog mol.biol fusion.protein mdr kinet ccr ## 01005 FALSE t(9;22) BCR/ABL p210 NEG dyploid FALSE ## 01010 FALSE simple alt. NEG &lt;NA&gt; POS dyploid FALSE ## 03002 NA &lt;NA&gt; BCR/ABL p190 NEG dyploid FALSE ## 04006 FALSE t(4;11) ALL1/AF4 &lt;NA&gt; NEG dyploid FALSE ## 04007 FALSE del(6q) NEG &lt;NA&gt; NEG dyploid FALSE ## relapse transplant f.u date.last.seen ## 01005 FALSE TRUE BMT / DEATH IN CR &lt;NA&gt; ## 01010 TRUE FALSE REL 8/28/2000 ## 03002 TRUE FALSE REL 10/15/1999 ## 04006 TRUE FALSE REL 1/23/1998 ## 04007 TRUE FALSE REL 11/4/1997 head(pdata[, 3:5]) ## sex age BT ## 01005 M 53 B2 ## 01010 M 19 B2 ## 03002 F 52 B4 ## 04006 M 38 B1 ## 04007 M 57 B2 ## 04008 M 17 B1 tail(pdata[, 3:5], 3) ## sex age BT ## 65003 M 30 T3 ## 83001 M 29 T2 ## LAL4 &lt;NA&gt; NA T head(pdata$age) ## [1] 53 19 52 38 57 17 head(pdata$sex) ## [1] M M F M M M ## Levels: F M head(pdata[pdata$age &gt; 21,]) ## cod diagnosis sex age BT remission CR date.cr t.4.11. t.9.22. ## 01005 1005 5/21/1997 M 53 B2 CR CR 8/6/1997 FALSE TRUE ## 03002 3002 6/24/1998 F 52 B4 CR CR 8/17/1998 NA NA ## 04006 4006 7/17/1997 M 38 B1 CR CR 9/8/1997 TRUE FALSE ## 04007 4007 7/22/1997 M 57 B2 CR CR 9/17/1997 FALSE FALSE ## 08001 8001 1/15/1997 M 40 B2 CR CR 3/26/1997 FALSE FALSE ## 08011 8011 8/21/1998 M 33 B3 CR CR 10/8/1998 FALSE FALSE ## cyto.normal citog mol.biol fusion.protein mdr kinet ccr ## 01005 FALSE t(9;22) BCR/ABL p210 NEG dyploid FALSE ## 03002 NA &lt;NA&gt; BCR/ABL p190 NEG dyploid FALSE ## 04006 FALSE t(4;11) ALL1/AF4 &lt;NA&gt; NEG dyploid FALSE ## 04007 FALSE del(6q) NEG &lt;NA&gt; NEG dyploid FALSE ## 08001 FALSE del(p15) BCR/ABL p190 NEG &lt;NA&gt; FALSE ## 08011 FALSE del(p15/p16) BCR/ABL p190/p210 NEG dyploid FALSE ## relapse transplant f.u date.last.seen ## 01005 FALSE TRUE BMT / DEATH IN CR &lt;NA&gt; ## 03002 TRUE FALSE REL 10/15/1999 ## 04006 TRUE FALSE REL 1/23/1998 ## 04007 TRUE FALSE REL 11/4/1997 ## 08001 TRUE FALSE REL 7/11/1997 ## 08011 FALSE TRUE BMT / DEATH IN CR &lt;NA&gt; It seems from below that there are 17 females over 40 in the data set. However, some individuals have NA for the age and / or sex, and these NA values propagate through some computations. Use table() to summarize the number of females over 40, and the number of samples for which this classification cannot be determined. When R encounters an NA value in a subscript index, it introduces an NA into the result. Observe this (rows of NA values introduced into the result) when subsetting using [ versus using the subset() function. idx &lt;- pdata$sex == &quot;F&quot; &amp; pdata$age &gt; 40 table(idx, useNA=&quot;ifany&quot;) ## idx ## FALSE TRUE &lt;NA&gt; ## 108 17 3 dim(pdata[idx,]) # WARNING: &#39;NA&#39; rows introduced ## [1] 20 21 tail(pdata[idx,]) ## cod diagnosis sex age BT remission CR ## 49006 49006 8/12/1998 F 43 B2 CR CR ## 57001 57001 1/29/1997 F 53 B3 &lt;NA&gt; DEATH IN INDUCTION ## 62001 62001 11/11/1997 F 50 B4 REF REF ## NA.1 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; NA &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 02020 2020 3/23/2000 F 48 T2 &lt;NA&gt; DEATH IN INDUCTION ## NA.2 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; NA &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## date.cr t.4.11. t.9.22. cyto.normal citog mol.biol ## 49006 11/19/1998 NA NA NA &lt;NA&gt; BCR/ABL ## 57001 &lt;NA&gt; FALSE FALSE TRUE normal NEG ## 62001 &lt;NA&gt; FALSE TRUE FALSE t(9;22)+other BCR/ABL ## NA.1 &lt;NA&gt; NA NA NA &lt;NA&gt; &lt;NA&gt; ## 02020 &lt;NA&gt; FALSE FALSE FALSE complex alt. NEG ## NA.2 &lt;NA&gt; NA NA NA &lt;NA&gt; &lt;NA&gt; ## fusion.protein mdr kinet ccr relapse transplant f.u ## 49006 p210 NEG dyploid FALSE TRUE FALSE REL ## 57001 &lt;NA&gt; NEG hyperd. NA NA NA &lt;NA&gt; ## 62001 &lt;NA&gt; NEG hyperd. NA NA NA &lt;NA&gt; ## NA.1 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; NA NA NA &lt;NA&gt; ## 02020 &lt;NA&gt; NEG dyploid NA NA NA &lt;NA&gt; ## NA.2 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; NA NA NA &lt;NA&gt; ## date.last.seen ## 49006 4/26/1999 ## 57001 &lt;NA&gt; ## 62001 &lt;NA&gt; ## NA.1 &lt;NA&gt; ## 02020 &lt;NA&gt; ## NA.2 &lt;NA&gt; dim(subset(pdata, idx)) # BETTER: no NA rows ## [1] 17 21 dim(subset(pdata, (sex == &quot;F&quot;) &amp; (age &gt; 40))) # alternative ## [1] 17 21 tail(subset(pdata,idx)) ## cod diagnosis sex age BT remission CR date.cr ## 28032 28032 9/26/1998 F 52 B1 CR CR 10/30/1998 ## 30001 30001 1/16/1997 F 54 B3 &lt;NA&gt; DEATH IN INDUCTION &lt;NA&gt; ## 49006 49006 8/12/1998 F 43 B2 CR CR 11/19/1998 ## 57001 57001 1/29/1997 F 53 B3 &lt;NA&gt; DEATH IN INDUCTION &lt;NA&gt; ## 62001 62001 11/11/1997 F 50 B4 REF REF &lt;NA&gt; ## 02020 2020 3/23/2000 F 48 T2 &lt;NA&gt; DEATH IN INDUCTION &lt;NA&gt; ## t.4.11. t.9.22. cyto.normal citog mol.biol fusion.protein ## 28032 TRUE FALSE FALSE t(4;11) ALL1/AF4 &lt;NA&gt; ## 30001 FALSE TRUE FALSE t(9;22)+other BCR/ABL p190 ## 49006 NA NA NA &lt;NA&gt; BCR/ABL p210 ## 57001 FALSE FALSE TRUE normal NEG &lt;NA&gt; ## 62001 FALSE TRUE FALSE t(9;22)+other BCR/ABL &lt;NA&gt; ## 02020 FALSE FALSE FALSE complex alt. NEG &lt;NA&gt; ## mdr kinet ccr relapse transplant f.u date.last.seen ## 28032 NEG dyploid TRUE FALSE FALSE CCR 5/16/2002 ## 30001 NEG hyperd. NA NA NA &lt;NA&gt; &lt;NA&gt; ## 49006 NEG dyploid FALSE TRUE FALSE REL 4/26/1999 ## 57001 NEG hyperd. NA NA NA &lt;NA&gt; &lt;NA&gt; ## 62001 NEG hyperd. NA NA NA &lt;NA&gt; &lt;NA&gt; ## 02020 NEG dyploid NA NA NA &lt;NA&gt; &lt;NA&gt; ## robust `[`: exclude NA values dim(pdata[idx &amp; !is.na(idx),]) ## [1] 17 21 Use the mol.biol column to subset the data to contain just individuals with ‘BCR/ABL’ or ‘NEG’, e.g., bcrabl &lt;- subset(pdata, mol.biol %in% c(&quot;BCR/ABL&quot;, &quot;NEG&quot;)) The mol.biol column is a factor, and retains all levels even after subsetting. It is sometimes convenient to retain factor levels, but in our case we use droplevels() to removed unused levels bcrabl$mol.biol &lt;- droplevels(bcrabl$mol.biol) The BT column is a factor describing B- and T-cell subtypes levels(bcrabl$BT) ## [1] &quot;B&quot; &quot;B1&quot; &quot;B2&quot; &quot;B3&quot; &quot;B4&quot; &quot;T&quot; &quot;T1&quot; &quot;T2&quot; &quot;T3&quot; &quot;T4&quot; How might one collapse B1, B2, … to a single type B, and likewise for T1, T2, …, so there are only two subtypes, B and T? One strategy is to replace two-letter level (e.g., B1) with the single-letter level (e.g., B). Do this using substring() to select the first letter of level, and update the previous levels with the new value using levels&lt;-. table(bcrabl$BT) ## ## B B1 B2 B3 B4 T T1 T2 T3 T4 ## 4 9 35 22 9 5 1 15 9 2 levels(bcrabl$BT) &lt;- substring(levels(bcrabl$BT), 1, 1) table(bcrabl$BT) ## ## B T ## 79 32 Use aggregate() to count the number of samples with B- and T-cell types in each of the BCR/ABL and NEG groups aggregate(rownames(bcrabl) ~ BT + mol.biol, bcrabl, length) ## BT mol.biol rownames(bcrabl) ## 1 B BCR/ABL 37 ## 2 B NEG 42 ## 3 T NEG 32 Use aggregate() to calculate the average age of males and females in the BCR/ABL and NEG treatment groups. aggregate(age ~ mol.biol + sex, bcrabl, mean) ## mol.biol sex age ## 1 BCR/ABL F 39.93750 ## 2 NEG F 30.42105 ## 3 BCR/ABL M 40.50000 ## 4 NEG M 27.21154 Use t.test() to compare the age of individuals in the BCR/ABL versus NEG groups; visualize the results using boxplot(). In both cases, use the formula interface. Consult the help page ?t.test and re-do the test assuming that variance of ages in the two groups is identical. What parts of the test output change? t.test(age ~ mol.biol, bcrabl) ## ## Welch Two Sample t-test ## ## data: age by mol.biol ## t = 4.8172, df = 68.529, p-value = 8.401e-06 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## 7.13507 17.22408 ## sample estimates: ## mean in group BCR/ABL mean in group NEG ## 40.25000 28.07042 boxplot(age ~ mol.biol, bcrabl) "],
["exploration-and-simple-univariate-measures.html", "10 Exploration and simple univariate measures 10.1 Clean data 10.2 Weight in 1990 vs. 2010 Females 10.3 Weight and height in 2010 Males", " 10 Exploration and simple univariate measures path &lt;- file.choose() # look for BRFSS-subset.csv stopifnot(file.exists(path)) brfss &lt;- read.csv(path) 10.1 Clean data R read Year as an integer value, but it’s really a factor brfss$Year &lt;- factor(brfss$Year) 10.2 Weight in 1990 vs. 2010 Females Create a subset of the data brfssFemale &lt;- brfss[brfss$Sex == &quot;Female&quot;,] summary(brfssFemale) ## Age Weight Sex Height ## Min. :18.00 Min. : 36.29 Female:12039 Min. :105.0 ## 1st Qu.:37.00 1st Qu.: 57.61 Male : 0 1st Qu.:157.5 ## Median :52.00 Median : 65.77 Median :163.0 ## Mean :51.92 Mean : 69.05 Mean :163.3 ## 3rd Qu.:67.00 3rd Qu.: 77.11 3rd Qu.:168.0 ## Max. :99.00 Max. :272.16 Max. :200.7 ## NA&#39;s :103 NA&#39;s :560 NA&#39;s :140 ## Year ## 1990:5718 ## 2010:6321 ## ## ## ## ## Visualize plot(Weight ~ Year, brfssFemale) Statistical test t.test(Weight ~ Year, brfssFemale) ## ## Welch Two Sample t-test ## ## data: Weight by Year ## t = -27.133, df = 11079, p-value &lt; 2.2e-16 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## -8.723607 -7.548102 ## sample estimates: ## mean in group 1990 mean in group 2010 ## 64.81838 72.95424 10.3 Weight and height in 2010 Males Create a subset of the data brfss2010Male &lt;- subset(brfss, Year == 2010 &amp; Sex == &quot;Male&quot;) summary(brfss2010Male) ## Age Weight Sex Height Year ## Min. :18.00 Min. : 36.29 Female: 0 Min. :135 1990: 0 ## 1st Qu.:45.00 1st Qu.: 77.11 Male :3679 1st Qu.:173 2010:3679 ## Median :57.00 Median : 86.18 Median :178 ## Mean :56.25 Mean : 88.85 Mean :178 ## 3rd Qu.:68.00 3rd Qu.: 99.79 3rd Qu.:183 ## Max. :99.00 Max. :278.96 Max. :218 ## NA&#39;s :30 NA&#39;s :49 NA&#39;s :31 Visualize the relationship hist(brfss2010Male$Weight) hist(brfss2010Male$Height) plot(Weight ~ Height, brfss2010Male) Fit a linear model (regression) fit &lt;- lm(Weight ~ Height, brfss2010Male) fit ## ## Call: ## lm(formula = Weight ~ Height, data = brfss2010Male) ## ## Coefficients: ## (Intercept) Height ## -86.8747 0.9873 Summarize as ANOVA table anova(fit) ## Analysis of Variance Table ## ## Response: Weight ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## Height 1 197664 197664 693.8 &lt; 2.2e-16 *** ## Residuals 3617 1030484 285 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Plot points, superpose fitted regression line; where am I? plot(Weight ~ Height, brfss2010Male) abline(fit, col=&quot;blue&quot;, lwd=2) points(180, 88, col=&quot;red&quot;, cex=4, pch=20) Class and available ‘methods’ class(fit) # &#39;noun&#39; methods(class=class(fit)) # &#39;verb&#39; Diagnostics plot(fit) ?plot.lm "],
["multivariate-analysis.html", "11 Multivariate analysis 11.1 Input and setup 11.2 Cleaning 11.3 Unsupervised machine learning – multi-dimensional scaling", " 11 Multivariate analysis This is a classic microarray experiment. Microarrays consist of ‘probesets’ that interogate genes for their level of expression. In the experiment we’re looking at, there are 12625 probesets measured on each of the 128 samples. The raw expression levels estimated by microarray assays require considerable pre-processing, the data we’ll work with has been pre-processed. 11.1 Input and setup Start by finding the expression data file on disk. path &lt;- file.choose() # look for ALL-expression.csv stopifnot(file.exists(path)) The data is stored in ‘comma-separate value’ format, with each probeset occupying a line, and the expression value for each sample in that probeset separated by a comma. Input the data using read.csv(). There are three challenges: The row names are present in the first column of the data. Tell R this by adding the argument row.names=1 to read.csv(). By default, R checks that column names do not look like numbers, but our column names do look like numbers. Use the argument check.colnames=FALSE to over-ride R’s default. read.csv() returns a data.frame. We could use a data.frame to work with our data, but really it is a matrix() – the columns are of the same type and measure the same thing. Use as.matrix() to coerce the data.frame we input to a matrix. exprs &lt;- read.csv(path, row.names=1, check.names=FALSE) exprs &lt;- as.matrix(exprs) class(exprs) ## [1] &quot;matrix&quot; dim(exprs) ## [1] 12625 128 exprs[1:6, 1:10] ## 01005 01010 03002 04006 04007 04008 ## 1000_at 7.597323 7.479445 7.567593 7.384684 7.905312 7.065914 ## 1001_at 5.046194 4.932537 4.799294 4.922627 4.844565 5.147762 ## 1002_f_at 3.900466 4.208155 3.886169 4.206798 3.416923 3.945869 ## 1003_s_at 5.903856 6.169024 5.860459 6.116890 5.687997 6.208061 ## 1004_at 5.925260 5.912780 5.893209 6.170245 5.615210 5.923487 ## 1005_at 8.570990 10.428299 9.616713 9.937155 9.983809 10.063484 ## 04010 04016 06002 08001 ## 1000_at 7.474537 7.536119 7.183331 7.735545 ## 1001_at 5.122518 5.016132 5.288943 4.633217 ## 1002_f_at 4.150506 3.576360 3.900935 3.630190 ## 1003_s_at 6.292713 5.665991 5.842326 5.875375 ## 1004_at 6.046607 5.738218 5.994515 5.748350 ## 1005_at 10.662059 11.269115 8.812869 10.165159 range(exprs) ## [1] 1.984919 14.126571 We’ll make use of the data describing the samples path &lt;- file.choose() # look for ALL-phenoData.csv stopifnot(file.exists(path)) pdata &lt;- read.csv(path, row.names=1) class(pdata) ## [1] &quot;data.frame&quot; dim(pdata) ## [1] 128 21 head(pdata) ## cod diagnosis sex age BT remission CR date.cr t.4.11. t.9.22. ## 01005 1005 5/21/1997 M 53 B2 CR CR 8/6/1997 FALSE TRUE ## 01010 1010 3/29/2000 M 19 B2 CR CR 6/27/2000 FALSE FALSE ## 03002 3002 6/24/1998 F 52 B4 CR CR 8/17/1998 NA NA ## 04006 4006 7/17/1997 M 38 B1 CR CR 9/8/1997 TRUE FALSE ## 04007 4007 7/22/1997 M 57 B2 CR CR 9/17/1997 FALSE FALSE ## 04008 4008 7/30/1997 M 17 B1 CR CR 9/27/1997 FALSE FALSE ## cyto.normal citog mol.biol fusion.protein mdr kinet ccr ## 01005 FALSE t(9;22) BCR/ABL p210 NEG dyploid FALSE ## 01010 FALSE simple alt. NEG &lt;NA&gt; POS dyploid FALSE ## 03002 NA &lt;NA&gt; BCR/ABL p190 NEG dyploid FALSE ## 04006 FALSE t(4;11) ALL1/AF4 &lt;NA&gt; NEG dyploid FALSE ## 04007 FALSE del(6q) NEG &lt;NA&gt; NEG dyploid FALSE ## 04008 FALSE complex alt. NEG &lt;NA&gt; NEG hyperd. FALSE ## relapse transplant f.u date.last.seen ## 01005 FALSE TRUE BMT / DEATH IN CR &lt;NA&gt; ## 01010 TRUE FALSE REL 8/28/2000 ## 03002 TRUE FALSE REL 10/15/1999 ## 04006 TRUE FALSE REL 1/23/1998 ## 04007 TRUE FALSE REL 11/4/1997 ## 04008 TRUE FALSE REL 12/15/1997 Some of the results below involve plots, and it’s convenient to choose pretty and functional colors. We use the RColorBrewer package; see colorbrewer.org library(RColorBrewer) ## not available? install package via RStudio highlight &lt;- brewer.pal(3, &quot;Set2&quot;)[1:2] `highlight’ is a vector of length 2, light and dark green. For more options see ?RColorBrewer and to view the predefined palettes display.brewer.all() 11.2 Cleaning We’ll add a column to pdata, derived from the BT column, to indicate whether the sample is B-cell or T-cell ALL. pdata$BorT &lt;- factor(substr(pdata$BT, 1, 1)) Microarray expression data is usually represented as a matrix of genes as rows and samples as columns. Statisticians usually think of their data as samples as rows, features as columns. So we’ll transpose the expression values exprs &lt;- t(exprs) Confirm that the pdata rows correspond to the exprs rows. stopifnot(identical(rownames(pdata), rownames(exprs))) 11.3 Unsupervised machine learning – multi-dimensional scaling Reduce high-dimensional data to lower dimension for visualization. Calculate distance between samples (requires that the expression matrix be transposed). d &lt;- dist(exprs) Use the cmdscale() function to summarize the distance matrix into two points in two dimensions. cmd &lt;- cmdscale(d) Visualize the result, coloring points by B- or T-cell status plot(cmd, col=highlight[pdata$BorT]) "],
["using-r-in-real-life.html", "12 Using R in real life 12.1 Organizing work 12.2 R Packages", " 12 Using R in real life 12.1 Organizing work Usually, work is organized into a directory with: A folder containing R scripts (scripts/BRFSS-visualize.R) ‘External’ data like the csv files that we’ve been working with, usually in a separate folder (extdata/BRFSS-subset.csv) (sometimes) R objects written to disk using saveRDS() (.rds files) that represent final results or intermediate ‘checkpoints’ (extdata/ALL-cleaned.rds). Read the data into an R session using readRDS(). Use setwd() to navigate to folder containing scripts/, extdata/ folder Source an entire script with source(&quot;scripts/BRFSS-visualization.R&quot;). R can also save the state of the current session (prompt when choosing to quit() R), and to view and save the history() of the the current session; I do not find these to be helpful in my own work flows. 12.2 R Packages All the functionality we have been using comes from packages that are automatically loaded when R starts. Loaded packages are on the search() path. search() ## [1] &quot;.GlobalEnv&quot; &quot;package:stats&quot; &quot;package:graphics&quot; ## [4] &quot;package:grDevices&quot; &quot;package:utils&quot; &quot;package:datasets&quot; ## [7] &quot;Autoloads&quot; &quot;package:base&quot; Additional packages may be installed in R’s libraries. Use `installed.packages() or the RStudio interface to see installed packages. To use these packages, it is necessary to attach them to the search path, e.g., for survival analysis library(&quot;survival&quot;) There are many thousands of R packages, and not all of them are installed in a single installation. Important repositories are CRAN: https://cran.r-project.org/ Bioconductor: https://bioconductor.org/packages Packages can be discovered in various ways, including CRAN Task Views and the Bioconductor web and Bioconductor support sites. To install a package, use install.packages() or, for Bioconductor packages, instructions on the package landing page, e.g., for GenomicRanges. Here we install the ggplot2 package. install.packages(&quot;ggplot2&quot;, repos=&quot;https://cran.r-project.org&quot;) A package needs to be installed once, and then can be used in any R session. "],
["graphics-and-visualization.html", "13 Graphics and Visualization 13.1 Base R Graphics 13.2 What makes for a good graphical display? 13.3 Grammar of Graphics: ggplot2", " 13 Graphics and Visualization Load the BRFSS-subset.csv data path &lt;- &quot;BRFSS-subset.csv&quot; # or file.choose() brfss &lt;- read.csv(path) Clean it by coercing Year to factor brfss$Year &lt;- factor(brfss$Year) 13.1 Base R Graphics Useful for quick exploration during a normal work flow. Main functions: plot(), hist(), boxplot(), … Graphical parameters – see ?par, but often provided as arguments to plot(), etc. Construct complicated plots by layering information, e.g., points, regression line, annotation. brfss2010Male &lt;- subset(brfss, (Year == 2010) &amp; (Sex == &quot;Male&quot;)) fit &lt;- lm(Weight ~ Height, brfss2010Male) plot(Weight ~ Height, brfss2010Male, main=&quot;2010, Males&quot;) abline(fit, lwd=2, col=&quot;blue&quot;) points(180, 90, pch=20, cex=3, col=&quot;red&quot;) Approach to complicated graphics: create a grid of panels (e.g., par(mfrows=c(1, 2)), populate with plots, restore original layout. brfssFemale &lt;- subset(brfss, Sex==&quot;Female&quot;) opar = par(mfrow=c(2, 1)) # layout: 2 &#39;rows&#39; and 1 &#39;column&#39; hist( # first panel -- 1990 brfssFemale[ brfssFemale$Year == 1990, &quot;Weight&quot; ], main = &quot;Female, 1990&quot;) hist( # second panel -- 2010 brfssFemale[ brfssFemale$Year == 2010, &quot;Weight&quot; ], main = &quot;Female, 2010&quot;) par(opar) # restore original layout 13.2 What makes for a good graphical display? Common scales for comparison Efficient use of space Careful color choice – qualitative, gradient, divergent schemes; color blind aware; … Emphasis on data rather than labels Convey statistical uncertainty 13.3 Grammar of Graphics: ggplot2 library(ggplot2) http://docs.ggplot2.org ‘Grammar of graphics’ Specify data and ‘aesthetics’ (aes()) to be plotted Add layers (geom_*()) of information ggplot(brfss2010Male, aes(x=Height, y=Weight)) + geom_point() + geom_smooth(method=&quot;lm&quot;) Capture a plot and augment it plt &lt;- ggplot(brfss2010Male, aes(x=Height, y=Weight)) + geom_point() + geom_smooth(method=&quot;lm&quot;) plt + labs(title = &quot;2010 Male&quot;) Use facet_*() for layouts ggplot(brfssFemale, aes(x=Height, y=Weight)) + geom_point() + geom_smooth(method=&quot;lm&quot;) + facet_grid(. ~ Year) Choose display to emphasize relevant aspects of data ggplot(brfssFemale, aes(Weight, fill=Year)) + geom_density(alpha=.2) "],
["bioconductor-infrastructure-for-sequence-analysis.html", "14 Bioconductor ‘infrastructure’ for sequence analysis 14.1 Introduction 14.2 Core packages 14.3 IRanges and GRanges 14.4 Biostrings (DNA or amino acid sequences) 14.5 Other formats and packages 14.6 Public Data and Annotation from AnnotationHub 14.7 Epigenomics case study 14.8 sessionInfo()", " 14 Bioconductor ‘infrastructure’ for sequence analysis We will need to install a few bioconductor packages for this section. source(&#39;https://bioconductor.org/biocLite.R&#39;) biocLite(c(&quot;GenomicAlignments&quot;, &quot;BSgenome.Hsapiens.UCSC.hg19&quot;, &quot;AnnotationHub&quot;, &quot;TxDb.Hsapiens.BioMart.igis&quot;, &quot;rtracklayer&quot;, &quot;readr&quot;, &quot;ComplexHeatmap&quot;, &quot;ggbio&quot;)) 14.1 Introduction 14.1.1 Classes, methods, and packages This section focuses on classes, methods, and packages, with the goal being to learn to navigate the help system and interactive discovery facilities. 14.1.2 Motivation Sequence analysis is specialized Large data needs to be processed in a memory- and time-efficient manner Specific algorithms have been developed for the unique characteristics of sequence data Additional considerations Re-use of existing, tested code is easier to do and less error-prone than re-inventing the wheel. Interoperability between packages is easier when the packages share similar data structures. Solution: use well-defined classes to represent complex data; methods operate on the classes to perform useful functions. Classes and methods are placed together and distributed as packages so that we can all benefit from the hard work and tested code of others. 14.2 Core packages VariantAnnotation | v GenomicFeatures | v BSgenome | v rtracklayer | v GenomicAlignments | | v v SummarizedExperiment Rsamtools ShortRead | | | | v v v v GenomicRanges Biostrings | | v v GenomeInfoDb (XVector) | | v v IRanges | v (S4Vectors) 14.3 IRanges and GRanges The IRanges package defines an important class for specifying integer ranges, e.g., library(IRanges) ir &lt;- IRanges(start=c(10, 20, 30), width=5) ir ## IRanges object with 3 ranges and 0 metadata columns: ## start end width ## &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; ## [1] 10 14 5 ## [2] 20 24 5 ## [3] 30 34 5 There are many interesting operations to be performed on ranges, e.g, flank() identifies adjacent ranges flank(ir, 3) ## IRanges object with 3 ranges and 0 metadata columns: ## start end width ## &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; ## [1] 7 9 3 ## [2] 17 19 3 ## [3] 27 29 3 The IRanges class is part of a class hierarchy. To see this, ask R for the class of ir, and for the class definition of the IRanges class class(ir) ## [1] &quot;IRanges&quot; ## attr(,&quot;package&quot;) ## [1] &quot;IRanges&quot; getClass(class(ir)) ## Class &quot;IRanges&quot; [package &quot;IRanges&quot;] ## ## Slots: ## ## Name: start width NAMES elementType elementMetadata ## Class: integer integer character_OR_NULL character DataTable_OR_NULL ## ## Name: metadata ## Class: list ## ## Extends: ## Class &quot;Ranges&quot;, directly ## Class &quot;IntegerList&quot;, by class &quot;Ranges&quot;, distance 2 ## Class &quot;RangesORmissing&quot;, by class &quot;Ranges&quot;, distance 2 ## Class &quot;AtomicList&quot;, by class &quot;Ranges&quot;, distance 3 ## Class &quot;List&quot;, by class &quot;Ranges&quot;, distance 4 ## Class &quot;Vector&quot;, by class &quot;Ranges&quot;, distance 5 ## Class &quot;Annotated&quot;, by class &quot;Ranges&quot;, distance 6 ## ## Known Subclasses: &quot;NormalIRanges&quot;, &quot;GroupingIRanges&quot; Notice that IRanges extends the Ranges class. Show Now try entering ?flank (if not using RStudio, enter ?&quot;flank,&lt;tab&gt;&quot; where &lt;tab&gt; means to press the tab key to ask for tab completion). You can see that there are help pages for flank operating on several different classes. Select the completion ?&quot;flank,Ranges-method&quot; and verify that you’re at the page that describes the method relevant to an IRanges instance. Explore other range-based operations. The GenomicRanges package extends the notion of ranges to include features relevant to application of ranges in sequence analysis, particularly the ability to associate a range with a sequence name (e.g., chromosome) and a strand. Create a GRanges instance based on our IRanges instance, as follows library(GenomicRanges) gr &lt;- GRanges(c(&quot;chr1&quot;, &quot;chr1&quot;, &quot;chr2&quot;), ir, strand=c(&quot;+&quot;, &quot;-&quot;, &quot;+&quot;)) gr ## GRanges object with 3 ranges and 0 metadata columns: ## seqnames ranges strand ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; ## [1] chr1 [10, 14] + ## [2] chr1 [20, 24] - ## [3] chr2 [30, 34] + ## ------- ## seqinfo: 2 sequences from an unspecified genome; no seqlengths The notion of flanking sequence has a more nuanced meaning in biology. In particular we might expect that flanking sequence on the + strand would precede the range, but on the minus strand would follow it. Verify that flank applied to a GRanges object has this behavior. flank(gr, 3) ## GRanges object with 3 ranges and 0 metadata columns: ## seqnames ranges strand ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; ## [1] chr1 [ 7, 9] + ## [2] chr1 [25, 27] - ## [3] chr2 [27, 29] + ## ------- ## seqinfo: 2 sequences from an unspecified genome; no seqlengths Discover what classes GRanges extends, find the help page documenting the behavior of flank when applied to a GRanges object, It seems like there might be a number of helpful methods available for working with genomic ranges; we can discover some of these from the command line, indicating that the methods should be on the current search() path methods(class=&quot;GRanges&quot;) ## [1] != [ [&lt;- %in% ## [5] &lt; &lt;= == &gt; ## [9] &gt;= $ $&lt;- aggregate ## [13] anyNA append as.character as.complex ## [17] as.data.frame as.env as.factor as.integer ## [21] as.list as.logical as.matrix as.numeric ## [25] as.raw BamViews bamWhich&lt;- blocks ## [29] browseGenome by c chrom ## [33] chrom&lt;- coerce coerce&lt;- countOverlaps ## [37] coverage disjoin disjointBins distance ## [41] distanceToNearest duplicated elementMetadata elementMetadata&lt;- ## [45] end end&lt;- eval expand ## [49] expand.grid export extractROWS extractUpstreamSeqs ## [53] findOverlaps flank follow gaps ## [57] getPromoterSeq granges head intersect ## [61] is.na is.unsorted isDisjoint length ## [65] lengths liftOver mapFromAlignments mapFromTranscripts ## [69] mapToAlignments mapToTranscripts match mcols ## [73] mcols&lt;- merge metadata metadata&lt;- ## [77] mstack names names&lt;- narrow ## [81] nearest NROW Ops order ## [85] overlapsAny parallelSlotNames pcompare pgap ## [89] pintersect pmapFromAlignments pmapFromTranscripts pmapToAlignments ## [93] pmapToTranscripts precede promoters psetdiff ## [97] punion range ranges ranges&lt;- ## [101] rank reduce relist relistToClass ## [105] rename rep rep.int replaceROWS ## [109] resize restrict rev ROWNAMES ## [113] rowRanges&lt;- ScanBamParam ScanBcfParam scanFa ## [117] scanTabix score score&lt;- selfmatch ## [121] seqinfo seqinfo&lt;- seqlevelsInUse seqnames ## [125] seqnames&lt;- setdiff setequal shift ## [129] shiftApply show showAsCell slidingWindows ## [133] sort split split&lt;- start ## [137] start&lt;- strand strand&lt;- subset ## [141] subsetByOverlaps summarizeOverlaps summary table ## [145] tail tapply tile transform ## [149] trim union unique update ## [153] updateObject values values&lt;- width ## [157] width&lt;- window window&lt;- with ## [161] xtabs ## see &#39;?methods&#39; for accessing help and source code Notice that the available flank() methods have been augmented by the methods defined in the GenomicRanges package, including those that are relevant (via inheritance) to the GRanges class. grep(&quot;flank&quot;, methods(class=&quot;GRanges&quot;), value=TRUE) ## [1] &quot;flank,GenomicRanges-method&quot; Verify that the help page documents the behavior we just observed. ?&quot;flank,GenomicRanges-method&quot; Use help() to list the help pages in the GenomicRanges package, and vignettes() to view and access available vignettes; these are also available in the Rstudio ‘Help’ tab. help(package=&quot;GenomicRanges&quot;) vignette(package=&quot;GenomicRanges&quot;) vignette(package=&quot;GenomicRanges&quot;, &quot;GenomicRangesHOWTOs&quot;) 14.3.1 The GRanges and GRangesList classes Aside: ‘TxDb’ packages provide an R representation of gene models library(TxDb.Hsapiens.UCSC.hg19.knownGene) txdb &lt;- TxDb.Hsapiens.UCSC.hg19.knownGene exons(): GRanges exons(txdb) ## GRanges object with 289969 ranges and 1 metadata column: ## seqnames ranges strand | exon_id ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; ## [1] chr1 [11874, 12227] + | 1 ## [2] chr1 [12595, 12721] + | 2 ## [3] chr1 [12613, 12721] + | 3 ## [4] chr1 [12646, 12697] + | 4 ## [5] chr1 [13221, 14409] + | 5 ## ... ... ... ... . ... ## [289965] chrUn_gl000241 [35706, 35859] - | 289965 ## [289966] chrUn_gl000241 [36711, 36875] - | 289966 ## [289967] chrUn_gl000243 [11501, 11530] + | 289967 ## [289968] chrUn_gl000243 [13608, 13637] + | 289968 ## [289969] chrUn_gl000247 [ 5787, 5816] - | 289969 ## ------- ## seqinfo: 93 sequences (1 circular) from hg19 genome exonsBy(): GRangesList exonsBy(txdb, &quot;tx&quot;) ## GRangesList object of length 82960: ## $1 ## GRanges object with 3 ranges and 3 metadata columns: ## seqnames ranges strand | exon_id exon_name exon_rank ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;character&gt; &lt;integer&gt; ## [1] chr1 [11874, 12227] + | 1 &lt;NA&gt; 1 ## [2] chr1 [12613, 12721] + | 3 &lt;NA&gt; 2 ## [3] chr1 [13221, 14409] + | 5 &lt;NA&gt; 3 ## ## $2 ## GRanges object with 3 ranges and 3 metadata columns: ## seqnames ranges strand | exon_id exon_name exon_rank ## [1] chr1 [11874, 12227] + | 1 &lt;NA&gt; 1 ## [2] chr1 [12595, 12721] + | 2 &lt;NA&gt; 2 ## [3] chr1 [13403, 14409] + | 6 &lt;NA&gt; 3 ## ## $3 ## GRanges object with 3 ranges and 3 metadata columns: ## seqnames ranges strand | exon_id exon_name exon_rank ## [1] chr1 [11874, 12227] + | 1 &lt;NA&gt; 1 ## [2] chr1 [12646, 12697] + | 4 &lt;NA&gt; 2 ## [3] chr1 [13221, 14409] + | 5 &lt;NA&gt; 3 ## ## ... ## &lt;82957 more elements&gt; ## ------- ## seqinfo: 93 sequences (1 circular) from hg19 genome GRanges / GRangesList are incredibly useful Represent annotations – genes, variants, regulatory elements, copy number regions, … Represent data – aligned reads, ChIP peaks, called variants, … 14.3.2 Algebra of genomic ranges Many biologically interesting questions represent operations on ranges Count overlaps between aligned reads and known genes – GenomicRanges::summarizeOverlaps() Genes nearest to regulatory regions – GenomicRanges::nearest(), [ChIPseeker][] Called variants relevant to clinical phenotypes – VariantFiltering GRanges Algebra Intra-range methods Independent of other ranges in the same object GRanges variants strand-aware shift(), narrow(), flank(), promoters(), resize(), restrict(), trim() See ?&quot;intra-range-methods&quot; Inter-range methods Depends on other ranges in the same object range(), reduce(), gaps(), disjoin() coverage() (!) see ?&quot;inter-range-methods&quot; Between-range methods Functions of two (or more) range objects findOverlaps(), countOverlaps(), …, %over%, %within%, %outside%; union(), intersect(), setdiff(), punion(), pintersect(), psetdiff() Alt Ranges Algebra 14.4 Biostrings (DNA or amino acid sequences) Classes XString, XStringSet, e.g., DNAString (genomes), DNAStringSet (reads) Methods – Cheat sheat Manipulation, e.g., reverseComplement() Summary, e.g., letterFrequency() Matching, e.g., matchPDict(), matchPWM() Related packages BSgenome Whole-genome representations Model and custom ShortRead FASTQ files Example Whole-genome sequences are distrubuted by ENSEMBL, NCBI, and others as FASTA files; model organism whole genome sequences are packaged into more user-friendly BSgenome packages. The following calculates GC content across chr14. library(BSgenome.Hsapiens.UCSC.hg19) chr14_range = GRanges(&quot;chr14&quot;, IRanges(1, seqlengths(Hsapiens)[&quot;chr14&quot;])) chr14_dna &lt;- getSeq(Hsapiens, chr14_range) letterFrequency(chr14_dna, &quot;GC&quot;, as.prob=TRUE) ## G|C ## [1,] 0.336276 14.5 Other formats and packages Alt Files and the Bioconductor packages that input them Acknowledgements Core (Seattle): Sonali Arora, Marc Carlson, Nate Hayden, Jim Hester, Valerie Obenchain, Hervé Pagès, Paul Shannon, Dan Tenenbaum. The research reported in this presentation was supported by the National Cancer Institute and the National Human Genome Research Institute of the National Institutes of Health under Award numbers U24CA180996 and U41HG004059, and the National Science Foundation under Award number 1247813. The content is solely the responsibility of the authors and does not necessarily represent the official views of the National Institutes of Health or the National Science Foundation. 14.6 Public Data and Annotation from AnnotationHub 14.6.1 Roadmap Epigenomics Project All Roadmap Epigenomics files are hosted here. If one had to download these files on their own, one would navigate through the web interface to find useful files, then use something like the following R code. url &lt;- &quot;http://egg2.wustl.edu/roadmap/data/byFileType/peaks/consolidated/broadPeak/E001-H3K4me1.broadPeak.gz&quot; filename &lt;- basename(url) download.file(url, destfile=filename) if (file.exists(filename)) data &lt;- import(filename, format=&quot;bed&quot;) This would have to be repeated for all files, and the onus would lie on the user to identify, download, import, and manage the local disk location of these files. AnnotationHub reduces this task to just a few lines of R code library(AnnotationHub) ## Loading required package: BiocGenerics ## Loading required package: methods ## Loading required package: parallel ## ## Attaching package: &#39;BiocGenerics&#39; ## The following objects are masked from &#39;package:parallel&#39;: ## ## clusterApply, clusterApplyLB, clusterCall, clusterEvalQ, clusterExport, clusterMap, ## parApply, parCapply, parLapply, parLapplyLB, parRapply, parSapply, parSapplyLB ## The following objects are masked from &#39;package:stats&#39;: ## ## IQR, mad, sd, var, xtabs ## The following objects are masked from &#39;package:base&#39;: ## ## anyDuplicated, append, as.data.frame, cbind, colMeans, colnames, colSums, do.call, ## duplicated, eval, evalq, Filter, Find, get, grep, grepl, intersect, is.unsorted, ## lapply, lengths, Map, mapply, match, mget, order, paste, pmax, pmax.int, pmin, ## pmin.int, Position, rank, rbind, Reduce, rowMeans, rownames, rowSums, sapply, ## setdiff, sort, table, tapply, union, unique, unsplit, which, which.max, which.min ah = AnnotationHub() ## snapshotDate(): 2017-04-24 epiFiles &lt;- query(ah, &quot;EpigenomeRoadMap&quot;) A look at the value returned by epiFiles shows us that 18248 roadmap resources are available via AnnotationHub. Additional information about the files is also available, e.g., where the files came from (dataprovider), genome, species, sourceurl, sourcetypes. epiFiles ## AnnotationHub with 18248 records ## # snapshotDate(): 2017-04-24 ## # $dataprovider: BroadInstitute ## # $species: Homo sapiens ## # $rdataclass: BigWigFile, GRanges, data.frame ## # additional mcols(): taxonomyid, genome, description, coordinate_1_based, maintainer, ## # rdatadateadded, preparerclass, tags, rdatapath, sourceurl, sourcetype ## # retrieve records with, e.g., &#39;object[[&quot;AH28856&quot;]]&#39; ## ## title ## AH28856 | E001-H3K4me1.broadPeak.gz ## AH28857 | E001-H3K4me3.broadPeak.gz ## AH28858 | E001-H3K9ac.broadPeak.gz ## AH28859 | E001-H3K9me3.broadPeak.gz ## AH28860 | E001-H3K27me3.broadPeak.gz ## ... ... ## AH49540 | E058_mCRF_FractionalMethylation.bigwig ## AH49541 | E059_mCRF_FractionalMethylation.bigwig ## AH49542 | E061_mCRF_FractionalMethylation.bigwig ## AH49543 | E081_mCRF_FractionalMethylation.bigwig ## AH49544 | E082_mCRF_FractionalMethylation.bigwig A good sanity check to ensure that we have files only from the Roadmap Epigenomics project is to check that all the files in the returned smaller hub object come from Homo sapiens and the hg19 genome unique(epiFiles$species) ## [1] &quot;Homo sapiens&quot; unique(epiFiles$genome) ## [1] &quot;hg19&quot; Broadly, one can get an idea of the different files from this project looking at the sourcetype table(epiFiles$sourcetype) ## ## BED BigWig GTF tab Zip ## 8298 9932 3 1 14 To get a more descriptive idea of these different files one can use: head(sort(table(epiFiles$description), decreasing=TRUE)) ## ## Bigwig File containing -log10(p-value) signal tracks from EpigenomeRoadMap Project ## 6881 ## Bigwig File containing fold enrichment signal tracks from EpigenomeRoadMap Project ## 2947 ## Narrow ChIP-seq peaks for consolidated epigenomes from EpigenomeRoadMap Project ## 2894 ## Broad ChIP-seq peaks for consolidated epigenomes from EpigenomeRoadMap Project ## 2534 ## Gapped ChIP-seq peaks for consolidated epigenomes from EpigenomeRoadMap Project ## 2534 ## Narrow DNasePeaks for consolidated epigenomes from EpigenomeRoadMap Project ## 131 The ‘metadata’ provided by the Roadmap Epigenomics Project is also available. Note that the information displayed about a hub with a single resource is quite different from the information displayed when the hub references more than one resource. metadata.tab &lt;- query(ah , c(&quot;EpigenomeRoadMap&quot;, &quot;Metadata&quot;)) metadata.tab ## AnnotationHub with 1 record ## # snapshotDate(): 2017-04-24 ## # names(): AH41830 ## # $dataprovider: BroadInstitute ## # $species: Homo sapiens ## # $rdataclass: data.frame ## # $title: EID_metadata.tab ## # $description: Metadata for EpigenomeRoadMap Project ## # $taxonomyid: 9606 ## # $genome: hg19 ## # $sourcetype: tab ## # $sourceurl: http://egg2.wustl.edu/roadmap/data/byFileType/metadata/EID_metadata.tab ## # $sourcelastmodifieddate: 2015-02-15 ## # $sourcesize: 18035 ## # $tags: c(&quot;EpigenomeRoadMap&quot;, &quot;Metadata&quot;) ## # retrieve record with &#39;object[[&quot;AH41830&quot;]]&#39; So far we have been exploring information about resources, without downloading the resource to a local cache and importing it into R. One can retrieve the resource using [[ as indicated at the end of the show method ## loading from cache &#39;/Users/sdavis2//.AnnotationHub/47270&#39; metadata.tab &lt;- ah[[&quot;AH41830&quot;]] ## loading from cache &#39;/Users/sdavis2//.AnnotationHub/47270&#39; The metadata.tab file is returned as a data.frame. The first 6 rows of the first 5 columns are shown here: metadata.tab[1:6, 1:5] ## EID GROUP COLOR MNEMONIC STD_NAME ## 1 E001 ESC #924965 ESC.I3 ES-I3 Cells ## 2 E002 ESC #924965 ESC.WA7 ES-WA7 Cells ## 3 E003 ESC #924965 ESC.H1 H1 Cells ## 4 E004 ES-deriv #4178AE ESDR.H1.BMP4.MESO H1 BMP4 Derived Mesendoderm Cultured Cells ## 5 E005 ES-deriv #4178AE ESDR.H1.BMP4.TROP H1 BMP4 Derived Trophoblast Cultured Cells ## 6 E006 ES-deriv #4178AE ESDR.H1.MSC H1 Derived Mesenchymal Stem Cells One can keep constructing different queries using multiple arguments to trim down these 18248 to get the files one wants. For example, to get the ChIP-Seq files for consolidated epigenomes, one could use bpChipEpi &lt;- query(ah , c(&quot;EpigenomeRoadMap&quot;, &quot;broadPeak&quot;, &quot;chip&quot;, &quot;consolidated&quot;)) To get all the bigWig signal files, one can query the hub using allBigWigFiles &lt;- query(ah, c(&quot;EpigenomeRoadMap&quot;, &quot;BigWig&quot;)) To access the 15 state chromatin segmentations, one can use seg &lt;- query(ah, c(&quot;EpigenomeRoadMap&quot;, &quot;segmentations&quot;)) If one is interested in getting all the files related to one sample E126 &lt;- query(ah , c(&quot;EpigenomeRoadMap&quot;, &quot;E126&quot;, &quot;H3K4ME2&quot;)) E126 ## AnnotationHub with 6 records ## # snapshotDate(): 2017-04-24 ## # $dataprovider: BroadInstitute ## # $species: Homo sapiens ## # $rdataclass: BigWigFile, GRanges ## # additional mcols(): taxonomyid, genome, description, coordinate_1_based, maintainer, ## # rdatadateadded, preparerclass, tags, rdatapath, sourceurl, sourcetype ## # retrieve records with, e.g., &#39;object[[&quot;AH29817&quot;]]&#39; ## ## title ## AH29817 | E126-H3K4me2.broadPeak.gz ## AH30868 | E126-H3K4me2.narrowPeak.gz ## AH31801 | E126-H3K4me2.gappedPeak.gz ## AH32990 | E126-H3K4me2.fc.signal.bigwig ## AH34022 | E126-H3K4me2.pval.signal.bigwig ## AH40177 | E126-H3K4me2.imputed.pval.signal.bigwig Hub resources can also be selected using $, subset(), and display(); see the main AnnotationHub vignette for additional detail. Hub resources are imported as the appropriate Bioconductor object for use in further analysis. For example, peak files are returned as GRanges objects. ## loading from cache &#39;/Users/sdavis2//.AnnotationHub/35257&#39; peaks &lt;- E126[[&#39;AH29817&#39;]] ## loading from cache &#39;/Users/sdavis2//.AnnotationHub/35257&#39; seqinfo(peaks) ## Seqinfo object with 93 sequences (1 circular) from hg19 genome: ## seqnames seqlengths isCircular genome ## chr1 249250621 FALSE hg19 ## chr2 243199373 FALSE hg19 ## chr3 198022430 FALSE hg19 ## chr4 191154276 FALSE hg19 ## chr5 180915260 FALSE hg19 ## ... ... ... ... ## chrUn_gl000245 36651 FALSE hg19 ## chrUn_gl000246 38154 FALSE hg19 ## chrUn_gl000247 36422 FALSE hg19 ## chrUn_gl000248 39786 FALSE hg19 ## chrUn_gl000249 38502 FALSE hg19 BigWig files are returned as BigWigFile objects. A BigWigFile is a reference to a file on disk; the data in the file can be read in using rtracklayer::import(), perhaps querying these large files for particular genomic regions of interest as described on the help page ?import.bw. Each record inside AnnotationHub is associated with a unique identifier. Most GRanges objects returned by AnnotationHub contain the unique AnnotationHub identifier of the resource from which the GRanges is derived. This can come handy when working with the GRanges object for a while, and additional information about the object (e.g., the name of the file in the cache, or the original sourceurl for the data underlying the resource) that is being worked with. metadata(peaks) ## $AnnotationHubName ## [1] &quot;AH29817&quot; ## ## $`File Name` ## [1] &quot;E126-H3K4me2.broadPeak.gz&quot; ## ## $`Data Source` ## [1] &quot;http://egg2.wustl.edu/roadmap/data/byFileType/peaks/consolidated/broadPeak/E126-H3K4me2.broadPeak.gz&quot; ## ## $Provider ## [1] &quot;BroadInstitute&quot; ## ## $Organism ## [1] &quot;Homo sapiens&quot; ## ## $`Taxonomy ID` ## [1] 9606 ah[metadata(peaks)$AnnotationHubName]$sourceurl ## [1] &quot;http://egg2.wustl.edu/roadmap/data/byFileType/peaks/consolidated/broadPeak/E126-H3K4me2.broadPeak.gz&quot; 14.6.2 Ensembl GTF TxDb gene models Bioconductor represents gene models using ‘transcript’ databases. These are available via packages such as TxDb.Hsapiens.UCSC.hg38.knownGene or can be constructed using functions such as GenomicFeatures::makeTxDbFromBiomart(). AnnotationHub provides an easy way to work with gene models published by Ensembl. We are going to be working with human data that are mapped to GRCh37 (hg19). We have a choice of providers (UCSC, NCBI, Ensembl), but we will just choose Ensembl here to minimize the amount of ID changing. query(ah,c(&#39;gtf&#39;,&#39;ensembl&#39;,&#39;sapiens&#39;,&#39;GRCh37&#39;)) ## AnnotationHub with 7 records ## # snapshotDate(): 2017-04-24 ## # $dataprovider: Ensembl ## # $species: Homo sapiens ## # $rdataclass: GRanges ## # additional mcols(): taxonomyid, genome, description, coordinate_1_based, maintainer, ## # rdatadateadded, preparerclass, tags, rdatapath, sourceurl, sourcetype ## # retrieve records with, e.g., &#39;object[[&quot;AH7558&quot;]]&#39; ## ## title ## AH7558 | Homo_sapiens.GRCh37.70.gtf ## AH7619 | Homo_sapiens.GRCh37.69.gtf ## AH7666 | Homo_sapiens.GRCh37.71.gtf ## AH7726 | Homo_sapiens.GRCh37.72.gtf ## AH7790 | Homo_sapiens.GRCh37.73.gtf ## AH8753 | Homo_sapiens.GRCh37.74.gtf ## AH10684 | Homo_sapiens.GRCh37.75.gtf We see that there is a GTF file describing gene models. The GTF file is imported as a GRanges instance, but with a number of columns that allow the Granges object to encode the complexity of exons, CDS, and utrs. gtf &lt;- ah[[&#39;AH10684&#39;]] ## loading from cache &#39;/Users/sdavis2//.AnnotationHub/10684&#39; ## using guess work to populate seqinfo head(gtf, 3) ## GRanges object with 3 ranges and 16 metadata columns: ## seqnames ranges strand | source type score phase ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;factor&gt; &lt;factor&gt; &lt;numeric&gt; &lt;integer&gt; ## [1] 1 [11869, 14412] + | pseudogene gene &lt;NA&gt; &lt;NA&gt; ## [2] 1 [11869, 14409] + | processed_transcript transcript &lt;NA&gt; &lt;NA&gt; ## [3] 1 [11869, 12227] + | processed_transcript exon &lt;NA&gt; &lt;NA&gt; ## gene_id gene_name gene_source gene_biotype transcript_id transcript_name ## &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; ## [1] ENSG00000223972 DDX11L1 ensembl_havana pseudogene &lt;NA&gt; &lt;NA&gt; ## [2] ENSG00000223972 DDX11L1 ensembl_havana pseudogene ENST00000456328 DDX11L1-002 ## [3] ENSG00000223972 DDX11L1 ensembl_havana pseudogene ENST00000456328 DDX11L1-002 ## transcript_source exon_number exon_id tag ccds_id protein_id ## &lt;character&gt; &lt;numeric&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; ## [1] &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## [2] havana &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## [3] havana 1 ENSE00002234944 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## ------- ## seqinfo: 265 sequences (1 circular) from GRCh37 genome It is trivial to make a transcript database, or TxDb, instance of these data. We will use this TxDb to quickly access gene annotation in genome context. library(GenomicFeatures) # for makeTxDbFromGRanges txdb &lt;- makeTxDbFromGRanges(gtf) 14.7 Epigenomics case study We are going to use data from the ENCODE project as a playground for using the Bioconductor ranges infrastructure. To keep things manageable, we will focus on only the K562 leukemia cell line and on histone marks. To keep the data smallish, but without loss of generality, we will use data that have been processed using a peak-caller and summarized as regions of statistically significant regions. Bioconductor has processed all of the ENCODE data into Bioconductor data structures (as well as thousands of other datasets) and then stored and made available via the AnnotationHub system we saw above. query(ah,c(&#39;K562&#39;,&#39;h3k&#39;,&#39;E123&#39;,&#39;narrow&#39;)) ## AnnotationHub with 10 records ## # snapshotDate(): 2017-04-24 ## # $dataprovider: BroadInstitute ## # $species: Homo sapiens ## # $rdataclass: GRanges ## # additional mcols(): taxonomyid, genome, description, coordinate_1_based, maintainer, ## # rdatadateadded, preparerclass, tags, rdatapath, sourceurl, sourcetype ## # retrieve records with, e.g., &#39;object[[&quot;AH30830&quot;]]&#39; ## ## title ## AH30830 | E123-H3K4me1.narrowPeak.gz ## AH30831 | E123-H3K4me2.narrowPeak.gz ## AH30832 | E123-H3K4me3.narrowPeak.gz ## AH30833 | E123-H3K9ac.narrowPeak.gz ## AH30834 | E123-H3K9me1.narrowPeak.gz ## AH30835 | E123-H3K9me3.narrowPeak.gz ## AH30836 | E123-H3K27ac.narrowPeak.gz ## AH30837 | E123-H3K27me3.narrowPeak.gz ## AH30838 | E123-H3K36me3.narrowPeak.gz ## AH30839 | E123-H3K79me2.narrowPeak.gz histoneSets = names(query(ah,c(&#39;K562&#39;,&#39;E123&#39;,&#39;h3k&#39;,&#39;narrow&#39;))) The histoneSets variable now contains the names AnnotationHub datasets from histone modification experiments done in K562 cells and summarized using a bioinformatics protocol tunes to produce narrow peaks. However, the data still need to be downloaded and then loaded into R memory. To load your own peaks into R, check out the rtracklayer::import() function. 14.7.1 Peak density across the genome Start (arbitrarily) with the first histoneSet by loading the dataset. histonePeaks = ah[[histoneSets[1]]] ## loading from cache &#39;/Users/sdavis2//.AnnotationHub/36270&#39; The first time the code above is executed, the data will be both downloaded and loaded into the variable histonePeaks. The next time that this line is run, a “cached” version of the data will be used, so no download needs to occur the second time. si = seqinfo(histonePeaks) si ## Seqinfo object with 93 sequences (1 circular) from hg19 genome: ## seqnames seqlengths isCircular genome ## chr1 249250621 FALSE hg19 ## chr2 243199373 FALSE hg19 ## chr3 198022430 FALSE hg19 ## chr4 191154276 FALSE hg19 ## chr5 180915260 FALSE hg19 ## ... ... ... ... ## chrUn_gl000245 36651 FALSE hg19 ## chrUn_gl000246 38154 FALSE hg19 ## chrUn_gl000247 36422 FALSE hg19 ## chrUn_gl000248 39786 FALSE hg19 ## chrUn_gl000249 38502 FALSE hg19 The next block of code looks long, but the main purpose of the code is to produce 100kb windows across the genomic so that we can count the number of H3K4me1 peaks in each 100kb window. Most of the lines are do deal with small issues of keeping chromosome names and lengths straight when transforming our data. fullchroms = as(si,&#39;GRanges&#39;) seqinfo(fullchroms) ## Seqinfo object with 93 sequences (1 circular) from hg19 genome: ## seqnames seqlengths isCircular genome ## chr1 249250621 FALSE hg19 ## chr2 243199373 FALSE hg19 ## chr3 198022430 FALSE hg19 ## chr4 191154276 FALSE hg19 ## chr5 180915260 FALSE hg19 ## ... ... ... ... ## chrUn_gl000245 36651 FALSE hg19 ## chrUn_gl000246 38154 FALSE hg19 ## chrUn_gl000247 36422 FALSE hg19 ## chrUn_gl000248 39786 FALSE hg19 ## chrUn_gl000249 38502 FALSE hg19 # 100kb bins # This is the work--using tile() tile0.1mb = unlist(tile(fullchroms,width=1e5)) seqinfo(tile0.1mb) = si tile0.1mb = keepStandardChromosomes(tile0.1mb,pruning.mode = &#39;coarse&#39;) histonePeaks = keepStandardChromosomes(histonePeaks,pruning.mode = &#39;coarse&#39;) seqlevelsStyle(tile0.1mb) = seqlevelsStyle(histonePeaks) histonePeaks=dropSeqlevels(histonePeaks,&#39;chrM&#39;) genome(tile0.1mb) = &#39;hg19&#39; Counting peaks in each 100kb window is VERY fast using the counterOverlaps() method. tile0.1mb$peakCount = countOverlaps(tile0.1mb,histonePeaks) While the following plot is not as informative as it could be, sometimes using a circular layout is a good way to show an overview of full genome datasets. Data on the scale of 100kb is probably still too fine-level for such a plot. library(ggbio) ggbio() + circle(tile0.1mb,geom=&#39;point&#39;, aes(y = peakCount), color=&#39;red&#39;, alpha=0.25, size=0.25, grid=TRUE, radius=60, trackWidth=30) + circle(tile0.1mb, geom = &quot;scale&quot;, size = 2,radius=90) + circle(tile0.1mb, geom=&#39;ideo&#39;,fill=&#39;gray70&#39;) Getting the GC content of the peaks is also straightforward. When you have two peaksets dnaInPeaks = getSeq(BSgenome.Hsapiens.UCSC.hg19,histonePeaks) percentGC = letterFrequency(dnaInPeaks,&#39;GC&#39;,as.prob=TRUE) To get a comparison set, just shift all regions to the left by 5kb (for example). shiftedPeaks = shift(histonePeaks,-5000) head(ranges(histonePeaks)) ## IRanges object with 6 ranges and 0 metadata columns: ## start end width ## &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; ## [1] 141522283 141524219 1937 ## [2] 23560218 23563994 3777 ## [3] 158460103 158464651 4549 ## [4] 1168831 1169616 786 ## [5] 80938636 80944222 5587 ## [6] 159273261 159274505 1245 # data shifted 5kb to the left head(ranges(shiftedPeaks)) ## IRanges object with 6 ranges and 0 metadata columns: ## start end width ## &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; ## [1] 141517283 141519219 1937 ## [2] 23555218 23558994 3777 ## [3] 158455103 158459651 4549 ## [4] 1163831 1164616 786 ## [5] 80933636 80939222 5587 ## [6] 159268261 159269505 1245 Grab the GC content and plot. dnaInShiftedPeaks = getSeq(BSgenome.Hsapiens.UCSC.hg19,shift(histonePeaks,-5000)) percentGC1 = letterFrequency(dnaInShiftedPeaks,&#39;GC&#39;,as.prob=TRUE) plot(density(percentGC)) lines(density(percentGC1),col=&#39;red&#39;) 14.7.2 Compare peak sets As with many datasets in biology, learning about how data relate to each other can be a very powerful technique for hypothesis generation. The goal of the next section is to determine the similarities aomong a set of 10 histone mark datasets in hopes of generating some hypotheses about the functionality of the histone marks. Start by loading the datasets that we found above for the K562 cell line. hpList = sapply(histoneSets,function(ahname) ah[[ahname]]) # get the &quot;titles&quot; for the experiment # And cleanup the messy names hptitles = gsub(&#39;E123-|\\\\.narrowPeak\\\\.gz&#39;,&#39;&#39;,ah[histoneSets]$title) names(hpList) = hptitles hptitles ## [1] &quot;H3K4me1&quot; &quot;H3K4me2&quot; &quot;H3K4me3&quot; &quot;H3K9ac&quot; &quot;H3K9me1&quot; &quot;H3K9me3&quot; &quot;H3K27ac&quot; &quot;H3K27me3&quot; ## [9] &quot;H3K36me3&quot; &quot;H3K79me2&quot; How can we compare two sets of regions? The Jaccard Similarity measure quantifies the proportion of shared peaks (or proportion of bases covered by the shared peaks) to that covered by the union of those peak sets. In mathematical terms, the Jaccard Index measures this similarity. \\[ J(A,B) = \\frac{\\left | A \\bigcap B \\right |}{\\left | A \\bigcup B \\right |} \\] The Jaccard Distance simply measures how dissimilar two sets of regions are (1-J(A,b)). \\[ d_J(A,B) = 1 - J(A,B) = 1 - \\frac{\\left | A \\bigcap B \\right |}{\\left | A \\bigcup B \\right |} \\] The regionJaccard() function takes as input two sets of regions and calculates the Jaccard Index using base-level overlaps (as opposed to whole-region overlaps). #&#39; Calculate Jaccard Similarity between two sets of ranges #&#39; #&#39; @param a A set of ranges #&#39; @param b A second set of ranges #&#39; #&#39; @details We calculate the Jaccard Distance #&#39; as a simple ratio of the number of #&#39; shared bases in the regions to #&#39; total number of bases covered by #&#39; both sets. #&#39; #&#39; @return a value between 0 and 1 regionJaccard = function(a,b) { sum(width(intersect(a,b)))/sum(width(union(a,b))) } We can try this on two peakSets: regionJaccard(hpList[[1]],hpList[[2]]) ## [1] 0.2811043 How would you interpret the result? To make addressing the question above a bit more intuitive, we can perform the same calculation, but between all pairs of regions using the multiRegStat() function below. multiRegStat &lt;- function(a,b, fun) { res &lt;- matrix(0L, length(a), length(b)) for (i in seq_along(a)) { for (j in seq_along(b)) { res[i,j] = fun(a[[i]],b[[j]]) } } if(!is.null(names(a))) rownames(res) = names(a) if(!is.null(names(b))) colnames(res) = names(b) res } res = multiRegStat(hpList,hpList,regionJaccard) res ## H3K4me1 H3K4me2 H3K4me3 H3K9ac H3K9me1 H3K9me3 H3K27ac ## H3K4me1 1.000000000 0.281104268 0.183791239 0.1927281172 0.0244827526 0.0027769509 0.2452366595 ## H3K4me2 0.281104268 1.000000000 0.637133591 0.5686767173 0.0175960031 0.0020254595 0.5097245220 ## H3K4me3 0.183791239 0.637133591 1.000000000 0.6514034239 0.0132880861 0.0022354848 0.5049994635 ## H3K9ac 0.192728117 0.568676717 0.651403424 1.0000000000 0.0129846178 0.0011958500 0.6090726088 ## H3K9me1 0.024482753 0.017596003 0.013288086 0.0129846178 1.0000000000 0.0006955316 0.0167764608 ## H3K9me3 0.002776951 0.002025459 0.002235485 0.0011958500 0.0006955316 1.0000000000 0.0039756797 ## H3K27ac 0.245236659 0.509724522 0.504999464 0.6090726088 0.0167764608 0.0039756797 1.0000000000 ## H3K27me3 0.004769609 0.006489705 0.003637553 0.0007145309 0.0107676075 0.0016215449 0.0008692706 ## H3K36me3 0.059625145 0.034442331 0.029895734 0.0308737432 0.0202655273 0.0101396064 0.0417566558 ## H3K79me2 0.156555342 0.221234307 0.232402857 0.2325234359 0.0225853902 0.0035804367 0.2030078886 ## H3K27me3 H3K36me3 H3K79me2 ## H3K4me1 4.769609e-03 0.0596251450 1.565553e-01 ## H3K4me2 6.489705e-03 0.0344423310 2.212343e-01 ## H3K4me3 3.637553e-03 0.0298957337 2.324029e-01 ## H3K9ac 7.145309e-04 0.0308737432 2.325234e-01 ## H3K9me1 1.076761e-02 0.0202655273 2.258539e-02 ## H3K9me3 1.621545e-03 0.0101396064 3.580437e-03 ## H3K27ac 8.692706e-04 0.0417566558 2.030079e-01 ## H3K27me3 1.000000e+00 0.0003409222 8.774185e-05 ## H3K36me3 3.409222e-04 1.0000000000 1.170739e-01 ## H3K79me2 8.774185e-05 0.1170739250 1.000000e+00 The res matrix now describes the pairwise similarities between the various histone mark peak sets. Making a heatmap and annotating it with knowledge of wikipedia, for example is potentially helpful. library(ComplexHeatmap) annot = data.frame(exprStatus=c(&#39;Active&#39;,&#39;Active&#39;,&#39;Active&#39;,&#39;Active&#39;, &#39;Active&#39;,&#39;Repressed&#39;,&#39;Active&#39;,&#39;Repressed&#39;,NA,&#39;Active&#39;), locale=c(NA,NA,&#39;Promoter&#39;,&#39;Promoter&#39;,NA,&#39;Body&#39;,&#39;Enhancer&#39;,&#39;Body&#39;,&#39;Body&#39;,NA), row.names=hptitles) Heatmap(res,top_annotation=HeatmapAnnotation( df=annot,col=list(exprStatus=c(&#39;Active&#39;=&#39;yellow&#39;,Repressed=&#39;blue&#39;)))) What do you think of the plot above? 14.7.3 Histone profiles wndw = 2000 proms = promoters(txdb, upstream = wndw, downstream = wndw, columns = c(&#39;tx_name&#39;,&#39;gene_id&#39;)) ## Warning in valid.GenomicRanges.seqinfo(x, suggest.trim = TRUE): GRanges object contains 1 out-of-bound range located on sequence GL000199.1. Note that ## only ranges located on a non-circular sequence whose length is not NA can be considered ## out-of-bound (use seqlengths() and isCircular() to get the lengths and circularity flags ## of the underlying sequences). You can use trim() to trim these ranges. See ## ?`trim,GenomicRanges-method` for more information. ## Warning in valid.GenomicRanges.seqinfo(x, suggest.trim = TRUE): GRanges object contains 1 out-of-bound range located on sequence GL000199.1. Note that ## only ranges located on a non-circular sequence whose length is not NA can be considered ## out-of-bound (use seqlengths() and isCircular() to get the lengths and circularity flags ## of the underlying sequences). You can use trim() to trim these ranges. See ## ?`trim,GenomicRanges-method` for more information. ## Warning in valid.GenomicRanges.seqinfo(x, suggest.trim = TRUE): GRanges object contains 1 out-of-bound range located on sequence GL000199.1. Note that ## only ranges located on a non-circular sequence whose length is not NA can be considered ## out-of-bound (use seqlengths() and isCircular() to get the lengths and circularity flags ## of the underlying sequences). You can use trim() to trim these ranges. See ## ?`trim,GenomicRanges-method` for more information. ## Warning in valid.GenomicRanges.seqinfo(x, suggest.trim = TRUE): GRanges object contains 2 out-of-bound ranges located on sequences GL000199.1 and ## GL000240.1. Note that only ranges located on a non-circular sequence whose length is not ## NA can be considered out-of-bound (use seqlengths() and isCircular() to get the lengths ## and circularity flags of the underlying sequences). You can use trim() to trim these ## ranges. See ?`trim,GenomicRanges-method` for more information. proms = proms[sample(seq_along(proms),20000,replace=FALSE)] proms = keepStandardChromosomes(proms,pruning.mode=&#39;tidy&#39;) covg = coverage(hpList[[1]]) seqlevelsStyle(proms) = seqlevelsStyle(covg) covg = covg[seqlevels(proms)] vi = Views(covg,as(proms[strand(proms)==&#39;+&#39;,],&#39;RangesList&#39;)) m = as.matrix(vi) plot(colSums(m),type=&#39;l&#39;) histoneProfile = function(promoters,peaks,n_promoters=10000) { proms = promoters proms = proms[sample(seq_along(proms),min(length(proms),n_promoters),replace=FALSE)] proms = keepStandardChromosomes(proms,pruning.mode=&#39;tidy&#39;) covg = coverage(peaks) seqlevelsStyle(proms) = seqlevelsStyle(covg) covg = covg[seqlevels(proms)] vi = Views(covg,as(proms[strand(proms)==&#39;+&#39;,],&#39;RangesList&#39;)) return(colSums(as.matrix(vi),na.rm = TRUE)) } library(readr) k562expr = read_tsv(&#39;https://www.encodeproject.org/files/ENCFF812ADD/@@download/ENCFF812ADD.tsv&#39;) ## Parsed with column specification: ## cols( ## gene_id = col_character(), ## `transcript_id(s)` = col_character(), ## length = col_double(), ## effective_length = col_double(), ## expected_count = col_double(), ## TPM = col_double(), ## FPKM = col_double(), ## posterior_mean_count = col_double(), ## posterior_standard_deviation_of_count = col_double(), ## pme_TPM = col_double(), ## pme_FPKM = col_double(), ## TPM_ci_lower_bound = col_double(), ## TPM_ci_upper_bound = col_double(), ## FPKM_ci_lower_bound = col_double(), ## FPKM_ci_upper_bound = col_double() ## ) head(k562expr) ## # A tibble: 6 x 15 ## gene_id `transcript_id(s)` length effective_length expected_count TPM FPKM ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 10904 10904 93 60 0.00 0.00 0.00 ## 2 12954 12954 94 61 0.00 0.00 0.00 ## 3 12956 12956 72 39 0.00 0.00 0.00 ## 4 12958 12958 82 49 22.22 18.58 17.10 ## 5 12960 12960 73 40 0.00 0.00 0.00 ## 6 12962 12962 72 39 1.00 1.05 0.96 ## # ... with 8 more variables: posterior_mean_count &lt;dbl&gt;, ## # posterior_standard_deviation_of_count &lt;dbl&gt;, pme_TPM &lt;dbl&gt;, pme_FPKM &lt;dbl&gt;, ## # TPM_ci_lower_bound &lt;dbl&gt;, TPM_ci_upper_bound &lt;dbl&gt;, FPKM_ci_lower_bound &lt;dbl&gt;, ## # FPKM_ci_upper_bound &lt;dbl&gt; These data have several columns of values, including tpm or transcripts-per-million, which we be using as our measure of expression. Go ahead and take a look at the distribution and other characteristics of the tpm column. # Fix gene names k562expr$gene_id=sub(&#39;\\\\..*&#39;,&#39;&#39;,k562expr$gene_id) k562expr = subset(k562expr,grepl(&#39;ENSG&#39;,gene_id)) proms$TPM = k562expr$TPM[match(unlist(proms$gene_id),k562expr$gene_id)] proms$logTPM = log10(k562expr$TPM[match(unlist(proms$gene_id),k562expr$gene_id)]) head(proms) ## GRanges object with 6 ranges and 4 metadata columns: ## seqnames ranges strand | tx_name gene_id TPM logTPM ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;CharacterList&gt; &lt;numeric&gt; &lt;numeric&gt; ## [1] chr16 [ 11648301, 11652300] - | ENST00000575426 ENSG00000189067 4.78 0.6794279 ## [2] chr19 [ 3918505, 3922504] - | ENST00000584410 ENSG00000266627 0.00 -Inf ## [3] chrX [145894245, 145898244] - | ENST00000458472 ENSG00000224440 0.00 -Inf ## [4] chr15 [ 79269468, 79273467] - | ENST00000559926 ENSG00000058335 0.03 -1.5228787 ## [5] chr4 [ 52774919, 52778918] + | ENST00000510518 ENSG00000109184 15.79 1.1983821 ## [6] chr1 [213173577, 213177576] - | ENST00000473303 ENSG00000174606 12.34 1.0913152 ## ------- ## seqinfo: 25 sequences (1 circular) from GRCh37 genome promslow = proms[which(proms$logTPM&lt;median(proms$logTPM,na.rm=TRUE))] promshigh = proms[which(proms$logTPM&gt;=median(proms$logTPM,na.rm=TRUE))] mat = cbind(histoneProfile(promslow,hpList[[1]]), histoneProfile(promshigh,hpList[[1]]), histoneProfile(promslow,hpList[[10]]), histoneProfile(promshigh,hpList[[10]])) matplot(mat,type=&#39;l&#39;,main=paste(hptitles[1],hptitles[[10]], sep=&quot; &amp; &quot;)) legend(0,2000,legend=c(&#39;H3K4me1_low&#39;,&#39;H3K4me1_high&#39;,&#39;H3K79me2_low&#39;,&#39;H3K79me2_high&#39;), col=1:4,lty=1:4) 14.8 sessionInfo() sessionInfo() ## R Under development (unstable) (2016-10-26 r71594) ## Platform: x86_64-apple-darwin13.4.0 (64-bit) ## Running under: macOS Sierra 10.12.4 ## ## locale: ## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 ## ## attached base packages: ## [1] stats4 parallel stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] TxDb.Hsapiens.UCSC.hg19.knownGene_3.2.2 GenomicAlignments_1.11.11 ## [3] Rsamtools_1.27.13 SummarizedExperiment_1.5.9 ## [5] DelayedArray_0.1.11 matrixStats_0.52.2 ## [7] GenomicFeatures_1.27.9 AnnotationDbi_1.37.4 ## [9] Biobase_2.35.1 readr_1.1.1 ## [11] BSgenome.Hsapiens.UCSC.hg19_1.4.0 BSgenome_1.43.7 ## [13] Biostrings_2.43.8 XVector_0.15.2 ## [15] rtracklayer_1.35.6 GenomicRanges_1.27.23 ## [17] GenomeInfoDb_1.11.11 IRanges_2.9.19 ## [19] S4Vectors_0.13.17 shiny_1.0.1 ## [21] AnnotationHub_2.7.14 BiocGenerics_0.21.3 ## [23] plotly_4.7.0 ggplot2_2.2.1.9000 ## ## loaded via a namespace (and not attached): ## [1] httr_1.2.1 tidyr_0.6.1 jsonlite_1.4 ## [4] viridisLite_0.2.0 assertthat_0.2.0 interactiveDisplayBase_1.13.0 ## [7] GenomeInfoDbData_0.99.0 yaml_2.1.14 RSQLite_1.1-2 ## [10] backports_1.0.5 lattice_0.20-35 glue_1.1.1 ## [13] digest_0.6.12 colorspace_1.3-2 htmltools_0.3.5 ## [16] httpuv_1.3.3 Matrix_1.2-8 plyr_1.8.4 ## [19] XML_3.98-1.6 pkgconfig_2.0.1 biomaRt_2.32.1 ## [22] bookdown_0.4.1 zlibbioc_1.21.0 purrr_0.2.2 ## [25] xtable_1.8-2 scales_0.4.1 BiocParallel_1.9.6 ## [28] tibble_1.3.3 lazyeval_0.2.0 magrittr_1.5 ## [31] mime_0.5 memoise_1.1.0 evaluate_0.10 ## [34] BiocInstaller_1.26.0 tools_3.4.0 data.table_1.10.4 ## [37] hms_0.3 stringr_1.2.0 munsell_0.4.3 ## [40] bindrcpp_0.2 compiler_3.4.0 rlang_0.1.1 ## [43] grid_3.4.0 RCurl_1.95-4.8 htmlwidgets_0.8 ## [46] crosstalk_1.0.0 bitops_1.0-6 labeling_0.3 ## [49] rmarkdown_1.4 codetools_0.2-15 gtable_0.2.0 ## [52] DBI_0.6-1 curl_2.5 R6_2.2.0 ## [55] knitr_1.16 dplyr_0.7.1 bindr_0.1 ## [58] rprojroot_1.2 stringi_1.1.5 Rcpp_0.12.11 lsls— author: “Sean Davis” date: “6/29/2017” output: html_document: default pdf_document: default — "],
["appendix-a-swirl.html", "A Appendix A – Swirl", " A Appendix A – Swirl The following is from the swirl website. The swirl R package makes it fun and easy to learn R programming and data science. If you are new to R, have no fear. To get started, we need to install a new package into R. install.packages(&#39;swirl&#39;) Once installed, we want to load it into the R workspace so we can use it. library(&#39;swirl&#39;) Finally, to get going, start swirl and follow the instructions. swirl() "]
]
